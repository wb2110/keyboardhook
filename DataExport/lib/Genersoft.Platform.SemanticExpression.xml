<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Genersoft.Platform.SemanticExpression</name>
    </assembly>
    <members>
        <member name="T:Genersoft.Platform.SemanticExpression.OperatorTokenItem">
            <summary>
            运算符。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.TokenItem">
            <summary>
            词法单元。为避免和语法分析程序中的 Token 同名，故后加 Item。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.Name">
            <summary>
            获取或设置键值名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.MssName">
            <summary>
            获取或设置SqlServer名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.OraName">
            <summary>
            获取或设置Oracle名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.Sequence">
            <summary>
            获取或设置序号。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.ToolTipText">
            <summary>
            提示文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.InsertText">
            <summary>
            点击后插入到编辑控件中的文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.CursorOffset">
            <summary>
            以插入前的文本起始点为基准，调整插入光标到新的位置的偏移量。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.MssEnExpr">
            <summary>
            获取英文表达式中SqlServer使用的名称。如果MssName未设置，则返回键值名称的英文名。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.TokenItem.OraEnExpr">
            <summary>
            获取英文表达式中Oracle使用的名称。如果OraName未设置，则返回键值名称的英文名。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.XmlSchemaIdentifierTokenItem">
            <summary>
            数据模型字段标识符。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.IdentifierTokenItem">
            <summary>
            标识符。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.IdentifierTokenItem.IdentifierType">
            <summary>
            获取标识符类型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.IdentifierTokenItem.BindingItem">
            <summary>
            用于 DataGridView 的绑定项。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.IdentifierTokenItem.InsertSyntaxEditorText">
            <summary>
            获取插入到语法编辑控件(RichTextBox)中的文本。默认为语义化名称。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.IdentifierTokenItemType.Unknow">
            <summary>
            未知
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.IdentifierTokenItemType.XmlSchema">
            <summary>
            XmlSchema
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.IdentifierTokenItemType.Function">
            <summary>
            函数
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.IdentifierTokenItemType.SessionVariable">
            <summary>
            Session 变量
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.IdentifierTokenItemType.ContextVariable">
            <summary>
            上下文变量
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.IdentifierTokenItemType.SubExpression">
            <summary>
            子表达式
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.FunParameterList">
            <summary>
            获取或设置参数列表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.FunctionCategory">
            <summary>
            获取或设置函数分类。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.Name">
            <summary>
            获取或设置键值名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.ChName">
            <summary>
            获取中文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.EnName">
            <summary>
            获取英文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.MssName">
            <summary>
            获取或设置SQLServer数据库名称（DataBase模式时使用）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.OraName">
            <summary>
            获取或设置Oracle数据库名称（DataBase模式时使用）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.MssEnExpr">
            <summary>
            获取英文表达式中SqlServer使用的名称。如果MssName未设置，则返回英文名。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.OraEnExpr">
            <summary>
            获取英文表达式中Oracle使用的名称。如果OraName未设置，则返回英文名。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.InstanceName">
            <summary>
            获取或设置所在类的实例名称。如果此名称为空，则表示为JavaScript原生函数。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.AssmblyName">
            <summary>
            获取或设置程序集名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.ClassName">
            <summary>
            获取或设置所在类的类名（包含命名空间的类型全名）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.DesignAssmblyName">
            <summary>
             设计时调用函数自定义向导AssmblyName
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.DesignClassName">
            <summary>
            设计时调用函数自定义向导ClassName
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.Description">
            <summary>
            获取或设置描述（即帮助）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.IsParamsMethod">
            <summary>
            获取或设置是否为可变参数方法。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.IsNative">
            <summary>
            获取或设置是否原生函数。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.IsContainBracket">
            <summary>
            获取或设置形成函数是否包含括弧。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Function.RunMode">
            <summary>
            获取或设置运行方式（内存、数据库）。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormShowExceptionList.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormShowExceptionList.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormShowExceptionList.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntry">
            <summary>
            表示表达式编辑上下文项实体类。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntry.#ctor(System.String,System.String,System.String,Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType,System.String)">
            <summary>
            以指定的参数构造类的新实例。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="value">值。</param>
            <param name="type">类型。</param>
            <param name="description">描述。</param>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntry.EnName">
            <summary>
            获取或设置上下文项的英文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntry.CnName">
            <summary>
            获取或设置上下文项的中文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntry.Value">
            <summary>
            获取或设置上下文项的值。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntry.EntryType">
            <summary>
            获取或设置上下文项的类型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntry.Description">
            <summary>
            获取或设置上下文项的描述。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.CaseSensitive">
            <summary>
            Gets case sensitivity of the grammar. Read-only, true by default. 
            Can be set to false only through a parameter to grammar constructor.
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.Root">
            <summary>
            The main root entry for the grammar. 
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.SnippetRoots">
            <summary>
            Alternative roots for parsing code snippets.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.OnScannerSelectTerminal(Genersoft.Platform.SemanticExpression.Grammars.Parsing.ParsingContext)">
            <summary>
            Override this method to help scanner select a terminal to create token when there are more than one candidates
            for an input char. Context.CurrentTerminals contains candidate terminals; leave a single terminal in this list
            as the one to use.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.OnResolvingConflict(Genersoft.Platform.SemanticExpression.Grammars.Parsing.ConflictResolutionArgs)">
            <summary>
            Override this method to provide custom conflict resolution; for example, custom code may decide proper shift or reduce
            action based on preview of tokens ahead. 
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.AddTermsReportGroup(System.String,System.String[])">
            <summary>
            Creates a terminal reporting group, so all terminals in the group will be reported as a single "alias" in syntex error messages like
            "Syntax error, expected: [list of terms]"
            </summary>
            <param name="alias">An alias for all terminals in the group.</param>
            <param name="symbols">Symbols to be included into the group.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.AddTermsReportGroup(System.String,Genersoft.Platform.SemanticExpression.Grammars.Parsing.Terminal[])">
            <summary>
            Creates a terminal reporting group, so all terminals in the group will be reported as a single "alias" in syntex error messages like
            "Syntax error, expected: [list of terms]"
            </summary>
            <param name="alias">An alias for all terminals in the group.</param>
            <param name="terminals">Terminals to be included into the group.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.AddToNoReportGroup(System.String[])">
            <summary>
            Adds symbols to a group with no-report type, so symbols will not be shown in expected lists in syntax error messages. 
            </summary>
            <param name="symbols">Symbols to exclude.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.AddToNoReportGroup(Genersoft.Platform.SemanticExpression.Grammars.Parsing.Terminal[])">
            <summary>
            Adds symbols to a group with no-report type, so symbols will not be shown in expected lists in syntax error messages. 
            </summary>
            <param name="terminals">Symbols to exclude.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.Grammar.AddOperatorReportGroup(System.String)">
            <summary>
            Adds a group and an alias for all operator symbols used in the grammar.
            </summary>
            <param name="alias">An alias for operator symbols.</param>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.GSPEnvironmentHelper">
            <summary>
            提供GSP平台环境信息及相关操作方法。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.GSPEnvironmentHelper.GetUniversalConfigFileDirectory">
            <summary>
            获取全局配置文件所在的目录。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.GSPEnvironmentHelper.OpenOldExpressionDesigner(System.Collections.Generic.List{Genersoft.Platform.SemanticExpression.Builder.ReceivedEntry},System.String)">
            <summary>
            打开老表达式设计器。
            </summary>
            <param name="receivedEntries"></param>
            <param name="expressionText"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InertButton.Dispose(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InertButton.OnEnabledChanged(System.EventArgs)">
            <exclude/>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.IdentifierTokenItemDictionary">
            <summary>
            标识符字典。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1">
            <summary>
            以 KeyName 为 Key 的 Dictionary。
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.Add(Genersoft.Platform.SemanticExpression.KeyName,`0)">
            <summary>
            将指定的键和值添加到字典中。当字典中既不包含英文名相同的键，也不包含中文名相同的键时，才能添加成功。
            </summary>
            <param name="key">键。</param>
            <param name="value">值。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.ContainsKey(Genersoft.Platform.SemanticExpression.KeyName)">
            <summary>
            确定字典中是否包含指定的键。
            </summary>
            <param name="key">键。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.ContainsCnName(System.String)">
            <summary>
            确定字典中是否包含指定中文名称的键。
            </summary>
            <param name="cnName">键的中文名称。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.ContainsEnName(System.String)">
            <summary>
            确定字典中是否包含指定英文名称的键。
            </summary>
            <param name="enName">键的英文名称。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.Remove(Genersoft.Platform.SemanticExpression.KeyName)">
            <summary>
            移除指定的键的值。
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.RemoveByCnName(System.String)">
            <summary>
            移除指定的中文名称的键的值。
            </summary>
            <param name="cnName">键的中文名称。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.RemoveByEnName(System.String)">
            <summary>
            移除指定的英文名称的键的值。
            </summary>
            <param name="enName">键的英文名称。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.TryGetValue(Genersoft.Platform.SemanticExpression.KeyName,`0@)">
            <summary>
            获取与指定的键相关联的值。
            </summary>
            <param name="key">键。</param>
            <param name="value">值。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.TryGetValueByCnName(System.String,`0@)">
            <summary>
            获取与指定的中文名称的键相关联的值。
            </summary>
            <param name="cnName">键的中文名称。</param>
            <param name="value">值。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.TryGetValueByEnName(System.String,`0@)">
            <summary>
            获取与指定的英文名称的键相关联的值。
            </summary>
            <param name="enName">键的英文名称。</param>
            <param name="value">值。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.Clear">
            <summary>
            移除所有的键和值。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.GetEnumerator">
            <summary>
            返回循环访问的枚举器。
            </summary>
            <returns></returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.Keys">
            <summary>
            获取字典中键的集合。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.Values">
            <summary>
            获取字典中值的集合。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.Item(Genersoft.Platform.SemanticExpression.KeyName)">
            <summary>
            获取与指定的键相关联的值。
            </summary>
            <param name="key">键。</param>
            <returns></returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.KeyNameDictionary`1.Item(System.String)">
            <summary>
            获取与指定的中文名称的键相关联的值。
            </summary>
            <param name="cnName">键的中文名称。</param>
            <param name="value">值。</param>
            <returns></returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpEditorBindingItem.ExpressionCategory">
            <summary>
            获取或设置表达式类型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpEditorBindingItem.Name">
            <summary>
            获取或设置智能帮助名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpEditorBindingItem.DesignAssmblyName">
            <summary>
             获取或设置设计时向导AssmblyName。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpEditorBindingItem.DesignClassName">
            <summary>
            获取或设置设计时向导ClassName。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpEditorBindingItem.Tag">
            <summary>
            获取或设置自定义标记。
            </summary>
        </member>
        <member name="T:Jint.Native.JsDictionaryObject">
            <summary>
            Base class for a JsObject class.
            </summary>
            <remarks>
            Implements generic property storing mechanism
            </remarks>
        </member>
        <member name="T:Jint.Native.JsInstance">
            <summary>
            A base class for values in javascript.
            </summary>
        </member>
        <member name="M:Jint.Native.JsInstance.Call(Jint.Expressions.IJintVisitor,System.String,Jint.Native.JsInstance[])">
            <summary>
            This is a shortcut to a function call by name.
            </summary>
            <remarks>
            Since this method requires a visitor it's not a very usefull, so this method is deprecated.
            </remarks>
            <param name="visitor"></param>
            <param name="function"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="P:Jint.Native.JsInstance.Class">
            <summary>
            Class of an object, don't confuse with type of an object.
            </summary>
            <remarks>There are only six object types in the ecma262.3: Undefined, Null, Boolean, String, Number, Object</remarks>
        </member>
        <member name="P:Jint.Native.JsInstance.Type">
            <summary>
            A type of a JsObject
            </summary>
        </member>
        <member name="M:Jint.Native.JsDictionaryObject.#ctor">
            <summary>
            Creates new Object without prototype
            </summary>
        </member>
        <member name="M:Jint.Native.JsDictionaryObject.#ctor(Jint.Native.JsDictionaryObject)">
            <summary>
            Creates new object with an specified prototype
            </summary>
            <param name="prototype">Prototype</param>
        </member>
        <member name="M:Jint.Native.JsDictionaryObject.HasProperty(System.String)">
            <summary>
            Checks whether an object or it's [[prototype]] has the specified property.
            </summary>
            <param name="key">property name</param>
            <returns>true or false indicating check result</returns>
            <remarks>
            This implementation uses a HasOwnProperty method while walking a prototypes chain.
            </remarks>
        </member>
        <member name="M:Jint.Native.JsDictionaryObject.HasOwnProperty(System.String)">
            <summary>
            Checks whether object has an own property
            </summary>
            <param name="key">property name</param>
            <returns>true of false</returns>
        </member>
        <member name="P:Jint.Native.JsDictionaryObject.Extensible">
            <summary>
            Determines wheater object is extensible or not. Extensible object allows defining new own properties.
            </summary>
            <remarks>
            When object becomes non-extensible it can not become extansible again
            </remarks>
        </member>
        <member name="P:Jint.Native.JsDictionaryObject.Length">
            <summary>
            gets the number of an actually stored properties
            </summary>
            <remarks>
            This is a non ecma262 standart property
            </remarks>
        </member>
        <member name="P:Jint.Native.JsDictionaryObject.Prototype">
            <summary>
            ecma262 [[prototype]] property
            </summary>
        </member>
        <member name="M:Jint.Native.JsFunction.#ctor(Jint.Native.IGlobal)">
            <summary>
            
            </summary>
            <param name="global"></param>
        </member>
        <member name="M:Jint.Native.JsFunction.#ctor(Jint.Native.JsObject)">
            <summary>
            Init new function object with a specified prototype
            </summary>
            <param name="prototype">prototype for this object</param>
        </member>
        <member name="T:Jint.Native.NativeConstructor">
            <summary>
            A constructor function that reflects a native clr type to the js runtime.
            </summary>
            <remarks>
            This class doesn't used to wrap open generics, since open generics can't be
            used to create instances they are not considered as functions (constructors).
            </remarks>
        </member>
        <member name="M:Jint.Native.JsConstructor.#ctor(Jint.Native.IGlobal)">
            <summary>
            Constructs JsContructor, setting [[Prototype]] property to global.FunctionClass.PrototypeProperty
            </summary>
            <param name="global">Global</param>
        </member>
        <member name="M:Jint.Native.JsConstructor.#ctor(Jint.Native.IGlobal,Jint.Native.JsObject)">
            <summary>
            Special form of the contructor used when constructin JsFunctionConstructor
            </summary>
            <remarks>This constructor is called when the global.FunctionClass isn't set yet.</remarks>
            <param name="global">Global</param>
            <param name="prototype">Prototype</param>
        </member>
        <member name="M:Jint.Native.JsConstructor.Wrap``1(``0)">
            <summary>
            This method is used to wrap an native value with a js object of the specified type.
            </summary>
            <remarks>
            This method creates a new apropriate js object and stores
            </remarks>
            <typeparam name="T">A type of a native value to wrap</typeparam>
            <param name="value">A native value to wrap</param>
            <returns>A js instance</returns>
        </member>
        <member name="P:Jint.Native.JsConstructor.Global">
            <summary>
            Stores Global object used for creating this function.
            This property may be used in the InitProtype method.
            </summary>
        </member>
        <member name="M:Jint.Native.NativeConstructor.CreateStruct``1(Jint.Native.IGlobal,Jint.Native.JsInstance[])">
            <summary>
            A helper which conforms a ConstrutorImpl signature and used as a default constructor for the value types
            </summary>
            <typeparam name="T">A value type</typeparam>
            <param name="global">global object</param>
            <param name="args">Constructor args, ignored</param>
            <returns>A new boxed value objec of type T</returns>
        </member>
        <member name="M:Jint.Native.NativeConstructor.Execute(Jint.Expressions.IJintVisitor,Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            Peforms a construction of a CLR instance inside the specified 
            </summary>
            <param name="visitor"></param>
            <param name="that"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.NativeConstructor.Construct(Jint.Native.JsInstance[],System.Type[],Jint.Expressions.IJintVisitor)">
            <summary>
            Creates a new native object and wraps it with a JsObject.
            </summary>
            <remarks>
            This method is overriden to delegate a container creation to the <see cref="M:Jint.Native.NativeConstructor.Wrap``1(``0)"/> method.
            </remarks>
            <param name="parameters">a constructor arguments</param>
            <param name="genericArgs">Ignored since this class represents a non-generic types</param>
            <param name="visitor">Execution visitor</param>
            <returns>A newly created js object</returns>
        </member>
        <member name="M:Jint.Native.NativeConstructor.CreateInstance(Jint.Expressions.IJintVisitor,Jint.Native.JsInstance[])">
            <summary>
            Finds a best matched constructor and uses it to create a native object instance
            </summary>
            <param name="visitor">Execution visitor</param>
            <param name="parameters">Parameters for a constructor</param>
            <returns>A newly created native object</returns>
        </member>
        <member name="M:Jint.Native.JsObjectConstructor.New(Jint.Native.JsFunction)">
            <summary>
            Creates new JsObject, sets a [[Prototype]] to the Object.PrototypeProperty and a 'constructor' property to the specified function
            </summary>
            <param name="constructor">JsFunction which is used as a constructor</param>
            <returns>new object</returns>
        </member>
        <member name="M:Jint.Native.JsObjectConstructor.New(Jint.Native.JsFunction,Jint.Native.JsObject)">
            <summary>
            Creates new JsObject, sets a [[Prototype]] to the Prototype parameter and a 'constructor' property to the specified function.
            </summary>
            <param name="constructor">JsFunction which is used as a constructor</param>
            <param name="Prototype">JsObjetc which is used as a prototype</param>
            <returns>new object</returns>
        </member>
        <member name="M:Jint.Native.JsObjectConstructor.New(System.Object)">
            <summary>
            Creates a new object which holds a specified value
            </summary>
            <param name="value">Value to store in the new object</param>
            <returns>new object</returns>
        </member>
        <member name="M:Jint.Native.JsObjectConstructor.Execute(Jint.Expressions.IJintVisitor,Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.2.2.1
            </summary>
        </member>
        <member name="M:Jint.Native.JsObjectConstructor.GetPrototypeOfImpl(Jint.Native.JsInstance[])">
            <summary>
            15.2.3.2
            </summary>
            <returns></returns>
        </member>
        <member name="T:Jint.Marshal.JsMethodImpl">
            <summary>
            A delegate for a native implementation for JsFunction
            </summary>
            <param name="global">A reference to the global object</param>
            <param name="that">A target object</param>
            <param name="arguments">A list of arguments</param>
            <returns>A result of a function invocation</returns>
        </member>
        <member name="T:Jint.Marshal.ConstructorImpl">
            <summary>
            A wrapper around native constructor
            </summary>
            <param name="global">A reference to the global object</param>
            <param name="parameters">A list of arguments</param>
            <returns>A newly created object</returns>
        </member>
        <member name="T:Jint.Marshal.JsGetter">
            <summary>
            A wrapper around native property getter.
            </summary>
            <param name="that">A target object</param>
            <returns>A value of a property</returns>
        </member>
        <member name="T:Jint.Marshal.JsSetter">
            <summary>
            A wrapper around native property setter
            </summary>
            <param name="that">A target object</param>
            <param name="value">A new value for the property</param>
        </member>
        <member name="T:Jint.Marshal.JsIndexerGetter">
            <summary>
            A wrapper around native indexer getter
            </summary>
            <param name="that">A target js object</param>
            <param name="index">index</param>
            <returns>A value at the specified index</returns>
        </member>
        <member name="T:Jint.Marshal.JsIndexerSetter">
            <summary>
            A wrapper around native indexer setter
            </summary>
            <param name="that">A target js object</param>
            <param name="index">index</param>
            <param name="value">A value which should be set at the specified index</param>
        </member>
        <member name="F:Antlr.Runtime.TokenChannels.Default">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenChannels.Hidden">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XsdParser.ParseXmlSchema(System.String,System.String,System.String,System.String)">
            <summary>
            将XmlSchema解析成内存表示形式。
            </summary>
            <param name="enName">XmlSchema英文名称。</param>
            <param name="cnName">XmlSchema中文名称。</param>
            <param name="xmlSchema">XmlSchema文档。</param>
            <param name="description">XmlSchema的描述。</param>
            <returns></returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.XsdParser.ExpressionContext">
            <summary>
            获取或设置表达式上下文。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.DetailsControl.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DetailsControl.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DetailsControl.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.Win32.User32.SetMdiClientBorderStyle(System.Windows.Forms.Form,System.Windows.Forms.BorderStyle)">
            <summary>
            设置Mdi窗口客户区的边框样式
            </summary>
            <param name="mdiForm">Mdi窗口的Handle</param>
            <param name="borderStyle">边框样式</param>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager">
            <summary>
            为停靠窗体提供容器。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.#ctor">
            <summary>
            构造对象的新实例。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.AddDockForm(System.Windows.Forms.Form)">
            <summary>
            向停靠管理器中添加一个停靠窗体。
            </summary>
            <param name="dockForm"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.ShowDockForm(System.Windows.Forms.Form)">
            <summary>
            以停靠管理器的当前状态显示指定的停靠窗体并给予它焦点。
            </summary>
            <param name="dockForm">要显示的停靠窗体。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.GetDockFormState">
            <summary>
            获取停靠窗体的状态。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.ResetDockFormState(Genersoft.Platform.SemanticExpression.DockFormState)">
            <summary>
            重置停靠窗体状态。此方法不会抛出异常。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.m_ToolTip">
            <summary>
            自动隐藏和关闭按钮的工具提示
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.m_IsActiveControl">
            <summary>
            获取或设置是否为活动控件
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.m_MouseHook">
            <summary>
            鼠标钩子
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.m_AutoHidePanel">
            <summary>
            自动隐藏状态时的显示面板
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.OnLoad(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.OnDockChanged(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.OnSizeChanged(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.DockFormIsAutoPopUpOnMouseHover">
            <summary>
            获取或设置鼠标悬停时是否自动弹出停靠窗口(处于非自动隐藏状态时此设置不起作用)。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.DockFormSize">
            <summary>
            获取或设置停靠管理器窗体显示区域的大小。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.ActiveDockForm">
            <summary>
            获取或设置当前显示的窗体
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.DockFormVisible">
            <summary>
            获取或设置停靠窗体显示区域是可见的还是隐藏的
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.BaseControls.Docking.DockFormManager.IsAutoHide">
            <summary>
            获取或设置是否自动隐藏
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDebugResult.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDebugResult.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDebugResult.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.RecordNotFindMode">
            <summary>
            要获取数据的行号不存在时的返回值。在下列情况下此枚举值将发挥作用。1、记录数为0时；2、要获取的行号大于记录的数量。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Evaluation.RecordNotFindMode.DBNull">
            <summary>
            数据库空值。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Evaluation.RecordNotFindMode.Null">
            <summary>
            空值。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Evaluation.RecordNotFindMode.Empty">
            <summary>
            空字符串。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Evaluation.RecordNotFindMode.ThrowException">
            <summary>
            抛出错误。
            </summary>
        </member>
        <member name="T:Jint.Native.NativeIndexer">
            <summary>
            Represent a set of native overloads to set and get values using indexers.
            </summary>
        </member>
        <member name="T:Jint.Native.NativeDescriptor">
            <summary>
            Descriptor which get and set methods are implemented through delegates
            </summary>
        </member>
        <member name="M:Jint.Native.Descriptor.Delete">
            <summary>
            Marks a descriptor as a deleted.
            </summary>
            <remarks>
            A descriptor may be deleted to force a refresh of cached references.
            </remarks>
        </member>
        <member name="M:Jint.Native.Descriptor.Get(Jint.Native.JsDictionaryObject)">
            <summary>
            Gets a value stored in the descriptor.
            </summary>
            <param name="that">A target object. This has a meaning in case of descriptors which helds an accessors,
            in value descriptors this parameter is ignored.</param>
            <returns>A value stored in the descriptor</returns>
        </member>
        <member name="M:Jint.Native.Descriptor.Set(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance)">
            <summary>
            Sets a value.
            </summary>
            <param name="that">A target object. This has a meaning in case of descriptors which helds an accessors,
            in value descriptors this parameter is ignored.</param>
            <param name="value">A new value which should be stored in the descriptor.</param>
        </member>
        <member name="T:Jint.Native.ClrFunction">
            <summary>
            Wraps native function, i.e. 'this' parameter from the js calling context will be ommited
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tokens.Skip">
            <summary>
            In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
            will avoid creating a token for this symbol and try to fetch another.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            
              <remarks>
              To avoid English-only error messages and to generally make things
              as flexible as possible, these exceptions are not created with strings,
              but rather the information necessary to generate an error.  Then
              the various reporting methods in Parser and Lexer can be overridden
              to generate a localized error message.  For example, MismatchedToken
              exceptions are built with the expected token type.
              So, don't expect getMessage() to return anything.
            
              Note that as of Java 1.4, you can access the stack trace, which means
              that you can compute the complete trace of rules from the start symbol.
              This gives you considerable context information with which to generate
              useful error messages.
            
              ANTLR generates code that throws exceptions upon recognition error and
              also generates code to catch these exceptions in each rule.  If you
              want to quit upon first error, you can turn off the automatic error
              handling mechanism using rulecatch action, but you still need to
              override methods mismatch and recoverFromMismatchSet.
            
              In general, the recognition exceptions can track where in a grammar a
              problem occurred and/or what was the expected input.  While the parser
              knows its state (such as current input symbol and line info) that
              state can change before the exception is reported so current token index
              is computed and stored at exception time.  From this info, you can
              perhaps print an entire line of input not just a single token, for example.
              Better to just say the recognizer had a problem and then let the parser
              figure out a fancy report.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._input">
            <summary>What input stream did the error occur in?</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._k">
            <summary>
            What was the lookahead index when this exception was thrown?
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._index">
            <summary>What is index of token/char were we looking at when the error occurred?</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._token">
            <summary>
            The current Token when an error occurred.  Since not all streams
            can retrieve the ith Token, we have to track the Token object.
            For parsers.  Even when it's a tree parser, token might be set.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._node">
            <summary>
            If this is a tree parser exception, node is set to the node with
            the problem.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._c">
            <summary>The current char when an error occurred. For lexers.</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._line">
            <summary>
            Track the line (1-based) at which the error occurred in case this is
            generated from a lexer.  We need to track this since the
            unexpected char doesn't carry the line info.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._charPositionInLine">
            <summary>
            The 0-based index into the line where the error occurred.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognitionException._approximateLineInfo">
            <summary>
            If you are parsing a tree node stream, you will encounter som
            imaginary nodes w/o line/col info.  We now search backwards looking
            for most recent token with line/col info, but notify getErrorHeader()
            that info is approximate.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.RecognitionException.#ctor">
            <summary>Used for remote debugger deserialization</summary> 
        </member>
        <member name="P:Antlr.Runtime.RecognitionException.UnexpectedType">
            <summary>Return the token type or char of the unexpected input element</summary> 
        </member>
        <member name="T:Antlr.Runtime.EarlyExitException">
            <summary>The recognizer did not match anything for a (..)+ loop.</summary> 
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.XsdField">
            <summary>
            表示数据模型中的数据字段。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.Name">
            <summary>
            获取数据字段的名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.XPath">
            <summary>
            获取元素节点在Xml文档中的XPath（ADP格式）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.AbsoluteXPath">
            <summary>
            获取元素节点在Xml文档中的XPath（绝对路径）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.DefaultValue">
            <summary>
            获取字段的默认值。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.DataType">
            <summary>
            获取字段的数据类型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.Table">
            <summary>
            获取字段隶属的数据表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.CnName">
            <summary>
            获取数据字段的中文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.EnName">
            <summary>
            获取数据字段的英文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.CnThreeSectionFieldName">
            <summary>
            获取中文三段式字段名。形式为：数据模型中文名_表中文名_字段中文名
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdField.EnThreeSectionFieldName">
            <summary>
            获取英文三段式字段名。形式为：数据模型英文名.表英文名.字段英文名
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.GetExpressionVersion(System.String)">
            <summary>
            获取表达式的版本。
            </summary>
            <param name="expressionText">表达式文本。</param>
            <returns>表达式的版本。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.GetExpressionTextEntity(System.String)">
            <summary>
            获取表示用户最终存储的表达式文本的实体类。
            </summary>
            <param name="expressionText">最终存储的表达式的原始文本。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.BuildExpressionEntity(Genersoft.Platform.SemanticExpression.ExpressionContext,System.String)">
            <summary>
            构造 ExpressionEntity。
            </summary>
            <param name="context">表达式上下文。</param>
            <param name="syntaxText">语义化文本。</param>
            <returns>ExpressionEntity。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.BuildExprEventArgs(Genersoft.Platform.SemanticExpression.ExpressionContext,System.String)">
            <summary>
            构造 SemanticExprEventArgs 事件参数。
            </summary>
            <param name="context">表达式上下文。</param>
            <param name="syntaxText">语义化文本。</param>
            <returns>SemanticExprEventArgs 事件参数。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.ConvertToExpressionText(Genersoft.Platform.SemanticExpression.Common.ExpressionEntity)">
            <summary>
            转换为语义化版本格式(加上前后缀)。
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.IsSemanticExpressionText(System.String)">
            <summary>
            判断表达式文本是否为语义化版本格式。
            </summary>
            <param name="expressionText">表达式文本。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.ConvertFromExpressionText(System.String)">
            <summary>
            从语义化版本存储文本生成 ExpressionEntity。
            </summary>
            <param name="expressionText">语义化版本存储文本(包含前后缀)。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.BuildParseTree(Genersoft.Platform.SemanticExpression.ExpressionContext,System.String)">
            <summary>
            构造语法树。
            </summary>
            <param name="context">表达式上下文。</param>
            <param name="syntaxText">语义化文本。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.BuildAndVerifyParseTree(Genersoft.Platform.SemanticExpression.ExpressionContext,System.String)">
            <summary>
            构造语法树，并校验标识符的合法性。校验失败，抛出错误。
            </summary>
            <param name="context">表达式上下文。</param>
            <param name="syntaxText">语义化文本。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.BuildMemoryModeExpressionEntity(Genersoft.Platform.SemanticExpression.ExpressionContext,System.String)">
            <summary>
            构造内存类型的 ExpressionEntity。
            </summary>
            <param name="context">表达式上下文。</param>
            <param name="syntaxText">语义化文本。</param>
            <returns>ExpressionEntity。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContextHelper.BuildDataBaseExpressionEntity(Genersoft.Platform.SemanticExpression.ExpressionContext,System.String)">
            <summary>
            构造数据库类型的 ExpressionEntity。
            </summary>
            <param name="context">表达式上下文。</param>
            <param name="syntaxText">语义化文本。</param>
            <returns>ExpressionEntity。</returns>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SeparatorLine">
            <summary>
            可以带标题的分隔线控件
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SeparatorLine.#ctor">
            <summary>
            可以带标题的分隔线控件
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SeparatorLine.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SeparatorLine.OnResize(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SeparatorLine.OnFontChanged(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SeparatorLine.Caption">
            <summary>
            获取或设置分隔线标题
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SeparatorLine.CaptionMarginSpace">
            <summary>
            The distance in pixels form the control margin to caption text
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SeparatorLine.CaptionPadding">
            <summary>
            The space in pixels arrownd text caption
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SeparatorLine.LineVerticalAlign">
            <summary>
            The vertical alignement of the line within the space of the control
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SeparatorLine.CaptionOrizontalAlign">
            <summary>
            Tell where the text caption is aligned in the control
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SeparatorLine.VerticalAlign">
            <summary>
            线条垂直对齐方式
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.SeparatorLine.VerticalAlign.Top">
            <summary>
            顶部对齐
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.SeparatorLine.VerticalAlign.Middle">
            <summary>
            居中对齐
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.SeparatorLine.VerticalAlign.Bottom">
            <summary>
            底部对齐
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SeparatorLine.OrizontalAlign">
            <summary>
            标题水平对齐方式
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.SeparatorLine.OrizontalAlign.Left">
            <summary>
            靠左对齐
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.SeparatorLine.OrizontalAlign.Center">
            <summary>
            居中对齐
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.SeparatorLine.OrizontalAlign.Right">
            <summary>
            靠右对齐
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.KeyName">
            <summary>
            KeyNameDictionary 字典中的键值。对此类的相等运算进行了重载，中文名称相等，就相等。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyName.#ctor(System.String,System.String)">
            <summary>
            以指定的参数构造类的新实例。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称（即语义化名称）。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyName.ToString">
            <summary>
            输出对象的字符串表现形式。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyName.Equals(System.Object)">
            <summary>
            判断两个实例是否相等。
            </summary>
            <param name="obj">另一个实例。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyName.op_Equality(Genersoft.Platform.SemanticExpression.KeyName,Genersoft.Platform.SemanticExpression.KeyName)">
            <summary>
            重载等于运算符。
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyName.op_Inequality(Genersoft.Platform.SemanticExpression.KeyName,Genersoft.Platform.SemanticExpression.KeyName)">
            <summary>
            重载不等于运算符。
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyName.GetHashCode">
            <summary>
            返回对象的哈希代码（已重载，返回的是中文名的哈希代码）。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.KeyName.CompareTo(System.Object)">
            <summary>
            比较两个对象实例排序的结果。
            </summary>
            <param name="obj">另一个实例。</param>
            <returns></returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.KeyName.EnName">
            <summary>
            获取英文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.KeyName.CnName">
            <summary>
            获取中文名称（即语义化名称）。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.OptionsStatusHelper.GetDefaultOptionsStatus">
            <summary>
            获取默认选项配置。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.OptionsStatusHelper.GetDefaultGrammarColorTable">
            <summary>
            获取默认语法颜色表。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.OptionsStatusHelper.SaveOptionsStatusToFile(Genersoft.Platform.SemanticExpression.SemanticOptionsStatus,Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor)">
            <summary>
            将选项配置保存到文件。此方法不会抛出异常。
            </summary>
            <param name="status"></param>
            <param name="ctrl"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.OptionsStatusHelper.GetOptionsStatusFromFile(Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor)">
            <summary>
            获取用户保存的选项配置。如果自定义配置文件不存在或发生了异常，将返回默认配置状态。此方法不会抛出异常。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.OptionsStatusHelper.GetOptionStatusFileName(Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor)">
            <summary>
            获取用户保存选项状态文件名。
            </summary>
            <param name="ctrl">编辑器控件。</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Math.Complex64">
            <summary>
            Implementation of the complex number data type.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.ConstantTokenItem">
            <summary>
            常量
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.OperatorButtonData">
            <summary>
            关键字、运算符按钮的关联数据。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.OperatorButtonData.Text">
            <summary>
            显示在按钮上的文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.OperatorButtonData.ToolTipText">
            <summary>
            提示文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.OperatorButtonData.InsertText">
            <summary>
            点击后插入到编辑控件中的文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.OperatorButtonData.CursorOffset">
            <summary>
            以插入前的文本起始点为基准，调整插入光标到新的位置的偏移量。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.OperatorButtonData.TokenItemType">
            <summary>
            对应的词法单元类型。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprHelper">
            <summary>
            语义化表达式工具类。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprHelper.GetExpressionVersion(System.String)">
            <summary>
            获取表达式的版本。
            </summary>
            <param name="expressionText">表达式文本。</param>
            <returns>表达式的版本。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprHelper.BuildExpressionEntity(System.String)">
            <summary>
            从语义化表达式文本生成 ExpressionEntity。
            </summary>
            <param name="expressionText">语义化表达式文本。</param>
            <returns>语义化表达式实体类。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprHelper.BuildExceptionDetailMessage(System.Exception)">
            <summary>
            在扩展函数的异常处理中使用此方法，将 Exception.StackTrace 追加到 Exception.Message 中 。
            </summary>
            <param name="ex">异常。</param>
            <returns>整合后的异常消息。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprHelper.ConvertToDataSet(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            根据XmlSchema，将Xml实例转换成表达式解析时使用的 DataSet。
            </summary>
            <param name="schemaEnName">数据模型英文名称。</param>
            <param name="schemaCnName">数据模型中文名称。</param>
            <param name="xmlSchema">Xml架构。</param>
            <param name="xmlInstance">Xml实例。</param>
            <param name="validate">是否对Xml实例执行验证。</param>
            <returns>表达式解析时使用的 DataSet。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprHelper.BuildExpressionText(Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder,System.String)">
            <summary>
            根据表达式设计时构造类和中文表达式，构造语义化表达式文本。
            </summary>
            <param name="exprBuilder">表达式设计时构造类。</param>
            <param name="cnExpr">中文表达式（相当于用户在表达式设计器中输入的文本）。</param>
            <returns>语义化表达式文本。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprHelper.PreprocessXmlSchema(System.String)">
            <summary>
            预处理XmlSchema。
            </summary>
            <param name="xmlSchema">要处理的原始XmlSchema。</param>
            <remarks>
            <para>
            1、此方法执行以下转换：如果要处理的原始XmlSchema中的表或字段不包含中文名，则自动将其英文名转换为中文名。
            </para>
            <para>
            2、使用此方法的风险：试想这样一个场景，有一个字段英文名是[XXCODE]，没有定义中文名，使用此方法预处理后，用户在表达式定义中将使用[XXCODE]引用该字段。
            有一天，原始XmlSchema中给该字段定义了中文名为[某某编号]，再次使用此方法预处理时，则不会再对该字段进行转换。这样造成的后果是，
            当用户对以前定义的表达式进行修改时，如果要通过语法校验，则必须将引用[XXCODE]的地方修改为[某某编号]。
            </para>
            </remarks>
            <returns>处理后的XmlSchema。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprHelper.ParseXmlSchema(System.String,System.String,System.String,System.String)">
            <summary>
            将XmlSchema解析成语义化表达式使用的内存表示形式。
            </summary>
            <param name="enName">XmlSchema英文名称。</param>
            <param name="cnName">XmlSchema中文名称。</param>
            <param name="xmlSchema">XmlSchema文档。</param>
            <param name="description">XmlSchema的描述。</param>
            <returns>语义化表达式使用的XmlSchema内存表示形式 <see cref="T:Genersoft.Platform.SemanticExpression.Builder.XsdDocument"/>。</returns>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.DefaultFunction">
            <summary>
            此类设为公开是因为供解析引擎调用的原因，使用语义化表达式进行开发时，不要直接使用此类。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.IEvaluatorContextHolder">
            <summary>
            解析上下文持有者接口。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.IEvaluatorContextHolder.EvaluatorContext">
            <summary>
            获取或设置解析上下文。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.DefaultFunction.INSTANCENAME">
            <summary>
            函数实例名称。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetJavaScriptTransferFunction">
            <summary>
            获取 JavaScriptTransferFunction。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetSessionValue(System.String)">
            <summary>
            获取系统变量的值。
            </summary>
            <param name="name">变量名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetContextParameter(System.String)">
            <summary>
            获取上下文变量的值。
            </summary>
            <param name="name">变量名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetDefaultFieldValue(System.String)">
            <summary>
            获取字段的默认值。
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns>字段的默认值。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetFieldCode(System.String)">
            <summary>
            获取字段名。
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetCurrenRowColValue(System.String)">
            <summary>
            获取当前行数据的字段值
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetComputeData(System.String)">
            <summary>
            获取计算数据集合
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns>存储在 DataSet 中的数据的 XML 表现形式。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetDefinedRowFieldValue(System.String,System.Int32)">
            <summary>
            获取指定行指定字段的数据
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <param name="rowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetFirstRowFieldValue(System.String)">
            <summary>
            获取首行数据的某个字段的值
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetLastRowFieldValue(System.String)">
            <summary>
            获取最后一行数据的某个字段的值
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetFirstFieldValue(System.String,System.String)">
            <summary>
            获取指定条件下首行数据的某个字段的值
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <param name="where">用来筛选行的条件。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetLastFieldValue(System.String,System.String)">
            <summary>
            获取指定条件下最后一行数据的某个字段的值
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <param name="where">用来筛选行的条件。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetRelationTableColValue(System.String,System.String,System.String)">
            <summary>
            获取指定条件从表字段内容
            </summary>
            <param name="masterThreeSectionFieldName">主表三段式字段名。</param>
            <param name="detailThreeSectionFieldName">从表三段式字段名。</param>
            <param name="where">用来筛选行的条件。</param>
            <returns>过滤结果中首行的值。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetConditionRowFieldValue(System.String,System.String)">
            <summary>
            获取指定条件下字段值
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <param name="where">用来筛选行的条件。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.IsExistRecord(System.String,System.Object)">
            <summary>
            是否存在记录
            </summary>
            <param name="threeSectionFieldName"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetBoundNodeData(System.String)">
            <summary>
            获取ADP列表绑定数据
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetSubstring(System.String,System.Int32,System.Int32)">
            <summary>
            取子字符串。
            </summary>
            <param name="originalString">原字符串。</param>
            <param name="startIndex">从0开始起始位置。</param>
            <param name="length">字符数。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetStringLength(System.String)">
            <summary>
            取字符数。
            </summary>
            <param name="obj">字符串。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ReplaceString(System.String,System.String,System.String)">
            <summary>
            字符串替换。
            </summary>
            <param name="originalString">原字符串。</param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.CreateGuid">
            <summary>
            唯一标识符
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.CaseToSql(System.String)">
            <summary>
            
            </summary>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.IsNullEmpty(System.String)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringSubstring(System.String,System.Int32,System.Int32)">
            <summary>
            取子字符串。
            </summary>
            <param name="originalString">原字符串。</param>
            <param name="startIndex">从0开始起始位置。</param>
            <param name="length">字符数。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringLength(System.String)">
            <summary>
            取字符数。
            </summary>
            <param name="originalString">字符串。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringReplace(System.String,System.String,System.String)">
            <summary>
            字符串替换。
            </summary>
            <param name="originalString">原字符串。</param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringToUpper(System.String)">
            <summary>
            转为大写
            </summary>
            <param name="originalString"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringToLower(System.String)">
            <summary>
            转为小写
            </summary>
            <param name="originalString"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringIndexOf(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="originalString"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringLastIndexOf(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="originalString"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringTrimStart(System.String)">
            <summary>
            
            </summary>
            <param name="originalString"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringTrimEnd(System.String)">
            <summary>
            
            </summary>
            <param name="originalString"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.StringTrim(System.String)">
            <summary>
            
            </summary>
            <param name="originalString"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.DateTimeAddDays(System.String,System.Double)">
            <summary>
            增加指定的天数。
            </summary>
            <param name="date">原日期时间值。</param>
            <param name="value">增加值</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.DateTimeAddYears(System.String,System.Int32)">
            <summary>
            增加指定的年数。
            </summary>
            <param name="date">原日期时间值。</param>
            <param name="value">增加值</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.DateTimeAddMonths(System.String,System.Int32)">
            <summary>
            增加指定的月数。
            </summary>
            <param name="date">原日期时间值。</param>
            <param name="value">增加值</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetFirstDayOfMonth(System.String)">
            <summary>
            获取指定日期时间值所在月的第一天。
            </summary>
            <param name="date">日期时间值。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetLastDayOfMonth(System.String)">
            <summary>
            获取指定日期时间值所在月的最后一天。
            </summary>
            <param name="date">日期时间值。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.GetDateTimeNow">
            <summary>
            获取当前日期时间。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.CompareDate(System.String,System.String)">
            <summary>
            比较2个时间
            </summary>
            <param name="str1"></param>
            <param name="str2"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.FormatDate(System.String)">
            <summary>
            格式化当前日期
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.FormatDefineDate(System.String,System.String)">
            <summary>
            格式化指定日期
            </summary>
            <param name="format"></param>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToStringX(System.Object)">
            <summary>
            转为字符串。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToDateTime(System.Object)">
            <summary>
            转为日期时间。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToBoolean(System.Object)">
            <summary>
            转为布尔值。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToDecimal(System.Object)">
            <summary>
            转为数值。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToDouble(System.Object)">
            <summary>
            转为双精度浮点数。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToSingle(System.Object)">
            <summary>
            转为单精度浮点数。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToByte(System.Object)">
            <summary>
            转为8位无符号整数。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToInt16(System.Object)">
            <summary>
            转为16位有符号整数。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToInt32(System.Object)">
            <summary>
            转为32位有符号整数。
            </summary>
            <param name="obj">要转换的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.ToChineseMoney(System.Decimal)">
            <summary>
            转为中文大写金额。
            </summary>
            <param name="num">数值。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.IsDBNull(System.Object)">
            <summary>
            是数据库空值。
            </summary>
            <param name="obj">要检测的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.IsNull(System.Object)">
            <summary>
            是空值。
            </summary>
            <param name="obj">要检测的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.IsNullOrWhiteSpace(System.String)">
            <summary>
            是空串。
            </summary>
            <param name="obj">要检测的字符串。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.IsNaN(System.Object)">
            <summary>
            是非数字。
            </summary>
            <param name="obj">要检测的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.IsNumber(System.Object)">
            <summary>
            是数字。
            </summary>
            <param name="obj">要检测的对象。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.SumCol(System.String)">
            <summary>
            合计列值
            </summary>
            <param name="threeSectionFieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.SumColByCondition(System.String,System.String)">
            <summary>
            指定条件合计列值
            </summary>
            <param name="threeSectionFieldName"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.CountCol(System.String)">
            <summary>
            列行数
            </summary>
            <param name="threeSectionFieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.CountColByCondition(System.String,System.String)">
            <summary>
            指定条件列行数
            </summary>
            <param name="threeSectionFieldName"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.AvgCol(System.String)">
            <summary>
            列平均值
            </summary>
            <param name="threeSectionFieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.AvgColByCondition(System.String,System.String)">
            <summary>
            指定条件列平均值
            </summary>
            <param name="threeSectionFieldName"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.MaxCol(System.String)">
            <summary>
            列最大值。
            </summary>
            <param name="threeSectionFieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.MaxColByCondition(System.String,System.String)">
            <summary>
            指定条件列最大值。
            </summary>
            <param name="threeSectionFieldName"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.MinCol(System.String)">
            <summary>
            列最小值。
            </summary>
            <param name="threeSectionFieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.MinColByCondition(System.String,System.String)">
            <summary>
            指定条件列最小值。
            </summary>
            <param name="threeSectionFieldName"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.MaxDateTimeCol(System.String)">
            <summary>
            日期时间列最大值。
            </summary>
            <param name="threeSectionFieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.MaxDateTimeColByCondition(System.String,System.String)">
            <summary>
            指定条件日期时间列最大值。
            </summary>
            <param name="threeSectionFieldName"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.MinDateTimeCol(System.String)">
            <summary>
            日期时间列最小值。
            </summary>
            <param name="threeSectionFieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.MinDateTimeColByCondition(System.String,System.String)">
            <summary>
            指定条件日期时间列最小值。
            </summary>
            <param name="threeSectionFieldName"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.InternalGetCurrentRowIndex(System.String)">
            <summary>
            获取当前行索引。按以下优先级查找： ExtendedProperties 中的设置，全局上下文变量中的设置，默认值0。
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.InternalGetSessionVariableValue(System.String)">
            <summary>
            获取系统变量的值。
            </summary>
            <param name="name">变量名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.InternalGetContextVariableValue(System.String)">
            <summary>
            获取上下文变量的值。
            </summary>
            <param name="name">变量名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.InternalGetFieldValueByDataView(System.Data.DataView,System.String,System.Int32)">
            <summary>
            获取指定行号，指定字段的值。
            </summary>
            <param name="dv">数据视图。</param>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <param name="rowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.InternalGetEvaluatorDataView(System.String)">
            <summary>
            根据三段式字段名获取求值时使用的数据视图。此方法中会检查数据集名、表名、字段名是否有效，无效时抛出异常。
            </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.InternalGetFieldValue(System.String,System.Int32)">
             <summary>
             获取字段的值。
             </summary>
            <param name="threeSectionFieldName">三段式字段名。</param>
             <param name="rowIndex">要获取数据的行号。</param>
             <returns>指定行的字段的值。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.InternalGetFieldValueDic(System.String)">
            <summary>
            获取指定字段全部记录行的值的字典。key：行号；value：值。
            </summary>
            <param name="threeSectionFieldName">三段式字段名</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DefaultFunction.InternalGetFieldValueDicByCondition(System.String,System.String)">
            <summary>
            获取指定字段、符合指定条件记录行的值的字典。key：行号；value：值。
            </summary>
            <param name="threeSectionFieldName">三段式字段名</param>
            <param name="where">过滤条件</param>
            <returns></returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.DefaultFunction.EvaluatorContext">
            <summary>
            获取或设置解析上下文。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction">
            <summary>
            此类设为公开是因为供解析引擎调用的原因，使用语义化表达式进行开发时，不要直接使用此类。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.#ctor(Genersoft.Platform.SemanticExpression.DefaultFunction)">
            <summary>
            以指定的参数初始化类的新实例。
            </summary>
            <param name="defaultFunction">默认函数实现类。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.PushParas(System.String)">
            <summary>
            
            </summary>
            <param name="anum"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.Reset">
            <summary>
            
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.AddDays">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.AddYears">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.AddMonths">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.GetFirstDayOfMonth">
            <summary>
            获取指定日期时间值所在月的第一天。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.GetLastDayOfMonth">
            <summary>
            获取指定日期时间值所在月的最后一天。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.DaysBetween">
            <summary>
            获取2个日期时间之间的间隔天数。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.ExecuteParamsMethod">
            <summary>
            执行可变参数方法。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.SumNumber">
            <summary>
            合计常量值。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.GetAgeByIdcard(System.String)">
            <summary>
            根据身份证号获取年龄
            </summary>
            <param name="str">身份证号</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.Round">
            <summary>
            四舍五入
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.JavaScriptTransferFunction.BankerRound">
            <summary>
            银行家舍入
            </summary>
            <returns></returns>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDebugData.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDebugData.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDebugData.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDebugData.showAll">
            <summary>
            是否显示全部变量、表和字段。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDebugData.ResetDataBinding(System.Boolean)">
            <summary>
            初始化绑定数据。
            </summary>
            <param name="showAll">是否显示全部变量和表。</param>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity">
            <summary>
            语义化表达式实体类。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.Version">
            <summary>
            获取版本标记。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.CnExpr">
            <summary>
            获取内存中文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.EnExpr">
            <summary>
            获取内存英文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.MssCnExpr">
            <summary>
            获取SQLServer数据库中文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.MssEnExpr">
            <summary>
            获取SQLServer数据库英文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.OraCnExpr">
            <summary>
            获取Oracle数据库中文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.OraEnExpr">
            <summary>
            获取Oracle数据库英文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.FunctionNameList">
            <summary>
            获取包含函数名称列表（此列表目前无效）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.InstanceNameList">
            <summary>
            获取包含函数实例名称列表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.FieldList">
            <summary>
            获取包含字段名列表（英文三段式字段名，形式为：数据模型英文名.表英文名.字段英文名）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.XpathFieldList">
            <summary>
            获取包含xpath列表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.HelpList">
            <summary>
            获取帮助信息列表（此列表目前无效）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.FunctionInstanceDic">
            <summary>
            包含函数实例字典。key:实例名称 value:函数信息
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.SessionVariableEnNameList">
            <summary>
            获取使用到的系统变量列表(英文名，包括所有子表达式中的)。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.ContextVariableEnNameList">
            <summary>
            获取使用到的上下文变量列表(英文名，包括所有子表达式中的)。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Common.ExpressionEntity.SubExpressionFieldList">
            <summary>
            获取子表达式中使用到的字段列表(三段式字段名)。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpInfo.Name">
            <summary>
            获取或设置智能帮助名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpInfo.DesignClassName">
            <summary>
            获取或设置所在类的类名（包含命名空间的类型全名）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpInfo.DesignAssmblyName">
            <summary>
            获取或设置程序集名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SmartHelpInfo.Tag">
            <summary>
            获取或设置自定义标记信息。
            </summary>
        </member>
        <member name="T:Jint.Native.PropertyAttributes">
            <summary>
            A property can have zero or more attributes from the following set
            </summary>
        </member>
        <member name="F:Jint.Native.PropertyAttributes.ReadOnly">
            <summary>
            The property is a read-only property. Attempts by ECMAScript code to write to
            the property will be ignored. (Note, however, that in some cases the value of a
            property with the ReadOnly attribute may change over time because of actions
            taken by the host environment; therefore “ReadOnly” does not mean “constant
            and unchanging”!)
            </summary>
        </member>
        <member name="F:Jint.Native.PropertyAttributes.DontEnum">
            <summary>
            The property is not to be enumerated by a for-in enumeration (section 12.6.4).
            </summary>
        </member>
        <member name="F:Jint.Native.PropertyAttributes.DontDelete">
            <summary>
            Attempts to delete the property will be ignored. See the description of the
            delete operator in section 11.4.1.
            </summary>
        </member>
        <member name="T:Jint.Native.NativeMethod">
            <summary>
            Wraps a single method which is implemented by the delegate
            </summary>
        </member>
        <member name="T:Jint.Expressions.MemberExpression">
            <summary>
            A MemberExpression represents an elements which applies on a previous Expression
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.FunctionParameterEditorBindingItem">
            <summary>
            函数参数编辑绑定项。
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeIterator">
            Return a node stream from a doubly-linked tree whose nodes
              know what child index they are.  No remove() is supported.
            
              Emit navigation nodes (DOWN, UP, and EOF) to let show tree structure.
        </member>
        <member name="F:Antlr.Runtime.Tree.TreeIterator.nodes">
            If we emit UP/DOWN nodes, we need to spit out multiple nodes per
            next() call.
        </member>
        <member name="T:Antlr.Runtime.RecognizerSharedState">
            <summary>
              The set of fields needed by an abstract recognizer to recognize input
              and recover from errors etc...  As a separate state object, it can be
              shared among multiple grammars; e.g., when one grammar imports another.
              </summary>
            
              <remarks>
              These fields are publically visible but the actual state pointer per
              parser is protected.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.following">
            <summary>
            Track the set of token types that can follow any rule invocation.
            Stack grows upwards.  When it hits the max, it grows 2x in size
            and keeps going.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.errorRecovery">
            <summary>
            This is true when we see an error and before having successfully
            matched a token.  Prevents generation of more than one error message
            per error.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.lastErrorIndex">
            <summary>
             The index into the input stream where the last error occurred.
            	This is used to prevent infinite loops where an error is found
             but no token is consumed during recovery...another error is found,
             ad naseum.  This is a failsafe mechanism to guarantee that at least
             one token/tree node is consumed for two errors.
             </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.failed">
            <summary>
            In lieu of a return value, this indicates that a rule or token
            has failed to match.  Reset to false upon valid token match.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.syntaxErrors">
            <summary>Did the recognizer encounter a syntax error?  Track how many.</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.backtracking">
            <summary>
            If 0, no backtracking is going on.  Safe to exec actions etc...
            If >0 then it's the level of backtracking.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.token">
            <summary>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartLine">
            <summary>The line on which the first character of the token resides</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.tokenStartCharPositionInLine">
            <summary>The character position of first character within the line</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.channel">
            <summary>The channel number for the current token</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.type">
            <summary>The token type for the current token</summary> 
        </member>
        <member name="F:Antlr.Runtime.RecognizerSharedState.text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormSemanticExprEditor.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormSemanticExprEditor.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormSemanticExprEditor.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.FormOutputDockForm">
            <summary>
            输出停靠窗口
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormOutputDockForm.components">
            <summary>
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormOutputDockForm.Dispose(System.Boolean)">
            <summary>
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormOutputDockForm.InitializeComponent">
            <summary>
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormOutputDockForm.#ctor">
            <summary>
            输出停靠窗口
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormOutputDockForm.AppendLine(System.String)">
            <summary>
            向输出文本框的当前文本追加一行文本
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormOutputDockForm.ClearText">
            <summary>
            清除输出文本框中的所有文本
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream">
            <summary>
            Interface for Terminals to access the source stream and produce tokens.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.CreateToken(Genersoft.Platform.SemanticExpression.Grammars.Parsing.Terminal)">
            <summary>
            Creates a new token based on current preview position.
            </summary>
            <param name="terminal">A terminal associated with the token.</param>
            <returns>New token.</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.CreateToken(Genersoft.Platform.SemanticExpression.Grammars.Parsing.Terminal,System.Object)">
            <summary>
            Creates a new token based on current preview position and sets its Value field.
            </summary>
            <param name="terminal">A terminal associated with the token.</param>
            <param name="value">The value associated with the token.</param>
            <returns>New token.</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.CreateErrorToken(System.String,System.Object[])">
            <summary>
            Creates error token with custom error message as its Value.
            </summary>
            <param name="message">Message template, can contain placeholder like {0} to be filled by values from <c>args</c>.</param>
            <param name="args">A list of message arguments</param>
            <returns>An error token.</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.MatchSymbol(System.String,System.Boolean)">
            <summary>
            Tries to match the symbol with the text at current preview position.
            </summary>
            <param name="symbol">A symbol to match</param>
            <param name="ignoreCase">True if char casing should be ignored.</param>
            <returns>True if there is a match; otherwise, false.</returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.Text">
            <summary>
            Returns the source text
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.Location">
            <summary>
            Current start location (position, row, column) of the new token
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.PreviewPosition">
            <summary>
            Gets or sets the current preview position in the source file. Must be greater or equal to Location.Position
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.PreviewChar">
            <summary>
            Gets a char at preview position
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ISourceStream.NextPreviewChar">
            <summary>
            Gets the char at position next after the PrevewPosition 
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Grammars.Parsing.ConflictResolutionArgs">
            <summary>
            The class provides arguments for custom conflict resolution grammar method.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.DelimiterTokenItem">
            <summary>
            分隔符
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.AutoHidePanel.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.AutoHidePanel.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.AutoHidePanel.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.FormShowException">
            <summary>
            显示异常信息窗体。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormShowException.#ctor(System.Exception)">
            <summary>
            使用指定的参数构造对象的实例。
            </summary>
            <param name="ex">要显示的异常。</param>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormShowException.components">
            <summary>
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormShowException.Dispose(System.Boolean)">
            <summary>
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormShowException.InitializeComponent">
            <summary>
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.EvaluatorDataSourceMode">
            <summary>
            求值时使用的数据源。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Evaluation.EvaluatorDataSourceMode.DataTable">
            <summary>
            使用数据表的原始数据。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Evaluation.EvaluatorDataSourceMode.DefaultView">
            <summary>
            使用数据表的默认视图中的数据。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.IFunctionWizard">
            <summary>
            自定义函数向导接口。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.IFunctionWizard.ShowWizard(Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext)">
            <summary>
            显示向导。
            </summary>
            <param name="context">语义化表达式设计时上下文。</param>
            <returns>向表达式编辑框中插入的文本。</returns>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer">
            <summary>
            语义化表达式查看器。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.#ctor">
            <summary>
            初始化<see cref="T:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer"/>类的新实例。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.OnLoad(System.EventArgs)">
            <summary>
            重载父类方法，关闭自动选词。
            </summary>
            <param name="e">事件参数。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.ResetExpressionContext(Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder)">
            <summary>
            重新设置表达式上下文。调用此方法会按照指定的表达式构造器重新初始化控件。
            </summary>
            <param name="builder">语义化表达式构造器。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.ResetExpressionText(System.String)">
            <summary>
            重新设置表达式文本。
            </summary>
            <param name="expressionText">表达式文本。</param>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.WordWrap">
            <summary>
            获取或设置是否自动换行。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprViewer.ScrollBars">
            <summary>
            获取或设置滚动条显示方式。
            </summary>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.EvaluateReplacePattern(System.String,System.String,System.String,System.String,System.Text.RegularExpressions.GroupCollection)">
            <summary>
            Used by the String object replace matched pattern
            </summary>
            <param name="matched"></param>
            <param name="before"></param>
            <param name="after"></param>
            <param name="newString"></param>
            <param name="groups"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.ValueOfImpl(Jint.Native.JsString,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.3
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.CharAtImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.4
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.CharCodeAtImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.5
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.FromCharCodeImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.3.2
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.LocaleCompareImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.9
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.MatchFunc(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.10
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.ReplaceImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.11
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.SearchImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.12
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.SliceImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.13
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.SplitImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.14
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.SubstringImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.15
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.ToLowerCaseImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.16
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.ToLocaleLowerCaseImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.17
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.ToUpperCaseImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.18
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.ToLocaleUpperCaseImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.5.4.19
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsStringConstructor.LengthImpl(Jint.Native.JsDictionaryObject)">
            <summary>
            15.5.5.1
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:Jint.Native.JsCallFunction">
            <summary>
            This class is used to model the function.call behaviour, which takes two arguments: this, and the parameters
            It is defined in Function.prototype so that every function can use it by default
            </summary>
        </member>
        <member name="P:Jint.Native.JsArguments.Length">
            <summary>
            The number of the actually passed arguments
            </summary>
        </member>
        <member name="T:Jint.Marshal.ProxyHelper">
            <summary>
            A helper class for generating proxy code while marshalling methods, properties and delegates.
            </summary>
        </member>
        <member name="M:Jint.Marshal.ProxyHelper.WrapMethod(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            Converts a native method to a standard delegate.
            </summary>
            <param name="info">A method to wrap</param>
            <param name="passGlobal">If this paramerter is true and the first argument of the constructor
            is IGlobal, a wrapper delegate will pass a Global JS object in the first parameter.</param>
            <returns>A wrapper delegate</returns>
        </member>
        <member name="M:Jint.Marshal.ProxyHelper.WrapConstructor(System.Reflection.ConstructorInfo,System.Boolean)">
            <summary>
            Converts a constructor to a standart delegate
            </summary>
            <param name="info">A constructor to wrap</param>
            <param name="passGlobal">If this paramerter is true and the first argument of the constructor
            is IGlobal, a wrapper delegate will pass a Global JS object in the first parameter.</param>
            <returns>A wrapper delegate</returns>
        </member>
        <member name="T:Antlr.Runtime.Tree.DotTreeGenerator">
            A utility class to generate DOT diagrams (graphviz) from
              arbitrary trees.  You can pass in your own templates and
              can pass in any kind of tree or use Tree interface method.
              I wanted this separator so that you don't have to include
              ST just to use the org.antlr.runtime.tree.* package.
              This is a set of non-static methods so you can subclass
              to override.  For example, here is an invocation:
            
                  CharStream input = new ANTLRInputStream(System.in);
                  TLexer lex = new TLexer(input);
                  CommonTokenStream tokens = new CommonTokenStream(lex);
                  TParser parser = new TParser(tokens);
                  TParser.e_return r = parser.e();
                  Tree t = (Tree)r.tree;
                  System.out.println(t.toStringTree());
                  DOTTreeGenerator gen = new DOTTreeGenerator();
                  StringTemplate st = gen.toDOT(t);
                  System.out.println(st);
        </member>
        <member name="F:Antlr.Runtime.Tree.DotTreeGenerator.nodeToNumberMap">
            Track node to number mapping so we can get proper node name back 
        </member>
        <member name="F:Antlr.Runtime.Tree.DotTreeGenerator.nodeNumber">
            Track node number so we can get unique node names 
        </member>
        <member name="M:Antlr.Runtime.Tree.DotTreeGenerator.ToDot(System.Object,Antlr.Runtime.Tree.ITreeAdaptor)">
            Generate DOT (graphviz) for a whole tree not just a node.
              For example, 3+4*5 should generate:
            
             digraph {
               node [shape=plaintext, fixedsize=true, fontsize=11, fontname="Courier",
                     width=.4, height=.2];
               edge [arrowsize=.7]
               "+"->3
               "+"->"*"
               "*"->4
               "*"->5
             }
            
             Takes a Tree interface object.
        </member>
        <member name="T:Antlr.Runtime.IAstRuleReturnScope`1">
            <summary>AST rules have trees</summary> 
        </member>
        <member name="T:Antlr.Runtime.IAstRuleReturnScope">
            <summary>AST rules have trees</summary> 
        </member>
        <member name="T:Antlr.Runtime.IRuleReturnScope">
            <summary>
            Rules can have start/stop info.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope.Start">
            <summary>
            Gets the start element from the input stream
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope.Stop">
            <summary>
            Gets the stop element from the input stream
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IAstRuleReturnScope.Tree">
            <summary>Has a value potentially if output=AST;</summary> 
        </member>
        <member name="P:Antlr.Runtime.IAstRuleReturnScope`1.Tree">
            <summary>Has a value potentially if output=AST;</summary> 
        </member>
        <member name="T:Antlr.Runtime.DFA">
            <summary>A DFA implemented as a set of transition tables.</summary>
            
              <remarks>
              Any state that has a semantic predicate edge is special; those states
              are generated with if-then-else structures in a specialStateTransition()
              which is generated by cyclicDFA template.
            
              There are at most 32767 states (16-bit signed short).
              Could get away with byte sometimes but would have to generate different
              types and the simulation code too.  For a point of reference, the Java
              lexer's Tokens rule DFA has 326 states roughly.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.DFA.recognizer">
            <summary>Which recognizer encloses this DFA?  Needed to check backtracking</summary> 
        </member>
        <member name="M:Antlr.Runtime.DFA.Predict(Antlr.Runtime.IIntStream)">
            <summary>
            From the input stream, predict what alternative will succeed
            using this DFA (representing the covering regular approximation
            to the underlying CFL).  Return an alternative number 1..n.  Throw
            an exception upon error.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.DFA.Error(Antlr.Runtime.NoViableAltException)">
            <summary>A hook for debugging interface</summary> 
        </member>
        <member name="M:Antlr.Runtime.DFA.UnpackEncodedString(System.String)">
            <summary>
            Given a String that has a run-length-encoding of some unsigned shorts
            like "\1\2\3\9", convert to short[] {2,9,9,9}.  We do this to avoid
            static short[] which generates so much init code that the class won't
            compile. :(
            </summary>
        </member>
        <member name="M:Antlr.Runtime.DFA.UnpackEncodedStringToUnsignedChars(System.String)">
            <summary>Hideous duplication of code, but I need different typed arrays out :(</summary> 
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SubExpressionIdentifierTokenItem">
            <summary>
            子表达式标识符。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SubExpressionIdentifierTokenItem.ExpressionEntity">
            <summary>
            获取或设置子表达式。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FunctionParamFieldType.fieldName">
            <summary>
            字段名称(配置文件中使用了"fieldName"字符串来解析枚举值，不能再更改。下同。)
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FunctionParamFieldType.fieldValue">
            <summary>
            字段值
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.ExtendConfigSection">
            <summary>
            表示扩展配置文件中 MemoryMode|DataBase 配置节。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.ExceptionDetail">
            <summary>
            表示错误详细信息。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExceptionDetail.#ctor">
            <summary>
            初始化 <see cref="T:Genersoft.Platform.SemanticExpression.ExceptionDetail"/> 类的新实例。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExceptionDetail.#ctor(System.Exception)">
            <summary>
            以指定的异常初始化 <see cref="T:Genersoft.Platform.SemanticExpression.ExceptionDetail"/> 类的新实例。
            </summary>
            <param name="exception">要序列化为 <see cref="T:Genersoft.Platform.SemanticExpression.ExceptionDetail"/> 对象的异常。</param>
            <exception cref="T:System.ArgumentNullException">exception 参数为 null。</exception>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExceptionDetail.ToString">
            <summary>
            返回异常的详细信息。
            </summary>
            <returns>异常的消息和堆栈跟踪。</returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExceptionDetail.HelpLink">
            <summary>
            获取或设置异常中的帮助链接。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExceptionDetail.InnerException">
            <summary>
            获取或设置异常中的表示内部异常的 <see cref="T:Genersoft.Platform.SemanticExpression.ExceptionDetail"/> 对象。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExceptionDetail.Message">
            <summary>
            获取或设置异常中的消息。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExceptionDetail.Source">
            <summary>
            获取或设置异常中的导致错误的应用程序或对象的名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExceptionDetail.StackTrace">
            <summary>
            获取或设置异常中的堆栈跟踪信息。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExceptionDetail.Type">
            <summary>
            获取或设置异常的类型字符串。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.DialogBox">
            <summary>
            显示各种信息对话框。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DialogBox.ShowInfomation(System.String)">
            <summary>
            显示提示信息对话框。此对话框只包含“确定”按钮。
            </summary>
            <param name="message">要显示的信息。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DialogBox.ShowInfomationQuestion(System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxDefaultButton)">
            <summary>
            显示提示性询问对话框。
            </summary>
            <param name="message">要显示的信息。</param>
            <param name="buttons">要显示的按钮。</param>
            <param name="defaultButton">默认按钮。</param>
            <returns>对话框的返回值。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DialogBox.ShowWarning(System.String)">
            <summary>
            显示警告信息对话框。此对话框只包含“确定”按钮。
            </summary>
            <param name="message">要显示的信息。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DialogBox.ShowWarningQuestion(System.String,System.Windows.Forms.MessageBoxButtons,System.Windows.Forms.MessageBoxDefaultButton)">
            <summary>
            显示警告性询问对话框。
            </summary>
            <param name="message">要显示的信息。</param>
            <param name="buttons">要显示的按钮。</param>
            <param name="defaultButton">默认按钮。</param>
            <returns>对话框的返回值。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DialogBox.ShowException(System.Exception)">
            <summary>
            显示错误信息对话框。此方法可以在非UI线程直接调用。
            </summary>
            <param name="exception">要显示的错误。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DialogBox.ShowExceptionList(System.Collections.Generic.IList{System.Exception})">
            <summary>
            显示批量错误信息对话框。此方法可以在非UI线程直接调用。
            </summary>
            <param name="exceptionList">要显示的错误列表。</param>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.HRObjectRelation">
            <summary>
            HR专用，表示在批量计算时的主从表关系。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.HRObjectRelation.ParentTableName">
            <summary>
            获取或设置主表表名。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.HRObjectRelation.ChildTableName">
            <summary>
            获取或设置从表表名。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.HRObjectRelation.KeyMapping">
            <summary>
            获取主从表主、外键对应关系。key：主表字段名；value：从表字段名。
            </summary>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.ToStringImpl(Jint.Native.JsArray,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.2
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.ToLocaleStringImpl(Jint.Native.JsArray,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.3
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Concat(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.4
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Join(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.5
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Pop(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.6
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Push(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.7
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Reverse(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.8
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Shift(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.9
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Slice(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.10
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Sort(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.11
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.Splice(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.12
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.UnShift(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.13
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.LastIndexOfImpl(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.15
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsArrayConstructor.IndexOfImpl(Jint.Native.JsObject,Jint.Native.JsInstance[])">
            <summary>
            15.4.4.15
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteRuleNodeStream">
            <summary>
            Queues up nodes matched on left side of -> in a tree parser. This is
            the analog of RewriteRuleTokenStream for normal parsers.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteRuleElementStream">
            <summary>
              A generic list of elements tracked in an alternative to be used in
              a -&gt; rewrite rule.  We need to subclass to fill in the next() method,
              which returns either an AST node wrapped around a token payload or
              an existing subtree.
              </summary>
            
              <remarks>
              Once you start next()ing, do not try to add more elements.  It will
              break the cursor tracking I believe.
            
              TODO: add mechanism to detect/puke on modification after reading from stream
              </remarks>
            
              <see cref="T:Antlr.Runtime.Tree.RewriteRuleSubtreeStream"/>
              <see cref="T:Antlr.Runtime.Tree.RewriteRuleTokenStream"/>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.Reset">
            <summary>
            Reset the condition of this stream so that it appears we have
            not consumed any of its elements.  Elements themselves are untouched.
            Once we reset the stream, any future use will need duplicates.  Set
            the dirty bit.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.NextTree">
            <summary>
            Return the next element in the stream.  If out of elements, throw
            an exception unless size()==1.  If size is 1, then return elements[0].
            Return a duplicate node/subtree if stream is out of elements and
            size==1.  If we've already used the element, dup (dirty bit set).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.NextCore">
            <summary>
            Do the work of getting the next element, making sure that it's
            a tree node or subtree.  Deal with the optimization of single-
            element list versus list of size > 1.  Throw an exception
            if the stream is empty or we're out of elements and size>1.
            protected so you can override in a subclass if necessary.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.Dup(System.Object)">
            <summary>
             When constructing trees, sometimes we need to dup a token or AST
            	subtree.  Dup'ing a token means just creating another AST node
             around it.  For trees, you must call the adaptor.dupTree() unless
             the element is for a tree root; then it must be a node dup.
             </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleElementStream.ToTree(System.Object)">
            <summary>
            Ensure stream emits trees; tokens must be converted to AST nodes.
            AST nodes can be passed through unmolested.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleNodeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleNodeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.ParseTree">
            <summary>
            A record of the rules used to match a token sequence.  The tokens
            end up as the leaves of this tree and rule nodes are the interior nodes.
            This really adds no functionality, it is just an alias for CommonTree
            that is more meaningful (specific) and holds a String to display for a node.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.BaseTree">
            <summary>
            A generic tree implementation with no payload.  You must subclass to
            actually have any user data.  ANTLR v3 uses a list of children approach
            instead of the child-sibling approach in v2.  A flat tree (a list) is
            an empty node whose children represent the list.  An empty, but
            non-null node is called "nil".
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.ITree">
            <summary>
              What does a tree look like?  ANTLR has a number of support classes
              such as CommonTreeNodeStream that work on these kinds of trees.  You
              don't have to make your trees implement this interface, but if you do,
              you'll be able to use more support code.
              </summary>
            
              <remarks>
              NOTE: When constructing trees, ANTLR can build any kind of tree; it can
              even use Token objects as trees if you add a child list to your tokens.
            
              This is a tree node without any payload; just navigation and factory stuff.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.HasAncestor(System.Int32)">
            <summary>Is there is a node above with token type ttype?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.GetAncestor(System.Int32)">
            <summary>Walk upwards and get first ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.GetAncestors">
            <summary>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.FreshenParentAndChildIndexes">
            <summary>Set the parent and child index values for all children</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.AddChild(Antlr.Runtime.Tree.ITree)">
            <summary>
            Add t as a child to this node.  If t is null, do nothing.  If t
            is nil, add all children of t to this' children.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.SetChild(System.Int32,Antlr.Runtime.Tree.ITree)">
            <summary>Set ith child (0..n-1) to t; t must be non-null and non-nil node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITree.ReplaceChildren(System.Int32,System.Int32,System.Object)">
            <summary>
            Delete children from start to stop and replace with t even if t is
            a list (nil-root tree).  num of children can increase or decrease.
            For huge child lists, inserting children can force walking rest of
            children to set their childindex; could be slow.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.ChildIndex">
            <summary>This node is what child index? 0..n-1</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.IsNil">
            <summary>
            Indicates the node is a nil node but may still have children, meaning
            the tree is a flat list.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.TokenStartIndex">
            <summary>
            What is the smallest token index (indexing from 0) for this node
            and its children?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.TokenStopIndex">
            <summary>
            What is the largest token index (indexing from 0) for this node
            and its children?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.Type">
            <summary>Return a token type; needed for tree parsing</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.ITree.Line">
            <summary>In case we don't have a token payload, what is the line for errors?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.#ctor(Antlr.Runtime.Tree.ITree)">
            <summary>
            Create a new node from an existing node does nothing for BaseTree
            as there are no fields other than the children list, which cannot
            be copied as the children are not considered part of this node. 
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.AddChild(Antlr.Runtime.Tree.ITree)">
            <summary>Add t as child of this node.</summary>
            
              <remarks>
              Warning: if t has no children, but child does
              and child isNil then this routine moves children to t via
              t.children = child.children; i.e., without copying the array.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.AddChildren(System.Collections.Generic.IEnumerable{Antlr.Runtime.Tree.ITree})">
            <summary>Add all elements of kids list as children of this node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.InsertChild(System.Int32,Antlr.Runtime.Tree.ITree)">
            Insert child t at child position i (0..n-1) by shifting children
            i+1..n-1 to the right one position. Set parent / indexes properly
            but does NOT collapse nil-rooted t's that come in here like addChild.
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ReplaceChildren(System.Int32,System.Int32,System.Object)">
            <summary>
            Delete children from start to stop and replace with t even if t is
            a list (nil-root tree).  num of children can increase or decrease.
            For huge child lists, inserting children can force walking rest of
            children to set their childindex; could be slow.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.CreateChildrenList">
            <summary>Override in a subclass to change the impl of children list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.FreshenParentAndChildIndexes">
            <summary>Set the parent and child index values for all child of t</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.HasAncestor(System.Int32)">
            <summary>Walk upwards looking for ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.GetAncestor(System.Int32)">
            <summary>Walk upwards and get first ancestor with this token type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.GetAncestors">
            <summary>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ToStringTree">
            <summary>Print out a whole tree not just a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTree.ToString">
            <summary>Override to say how a node (not a tree) should look as text</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.Children">
            <summary>
            Get the children internal List; note that if you directly mess with
            the list, do so at your own risk.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.Parent">
            <summary>BaseTree doesn't track parent pointers.</summary> 
        </member>
        <member name="P:Antlr.Runtime.Tree.BaseTree.ChildIndex">
            <summary>BaseTree doesn't track child indexes.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ParseTree.ToStringWithHiddenTokens">
            <summary>
            Emit a token and all hidden nodes before.  EOF node holds all
            hidden tokens after last real token.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ParseTree.ToInputString">
            <summary>
            Print out the leaves of this tree, which means printing original
            input back out.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.BaseTreeAdaptor">
            <summary>A TreeAdaptor that works with any Tree implementation.</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeAdaptor">
            <summary>
              How to create and navigate trees.  Rather than have a separate factory
              and adaptor, I've merged them.  Makes sense to encapsulate.
              </summary>
            
              <remarks>
              This takes the place of the tree construction code generated in the
              generated code in 2.x and the ASTFactory.
            
              I do not need to know the type of a tree at all so they are all
              generic Objects.  This may increase the amount of typecasting needed. :(
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(Antlr.Runtime.IToken)">
            <summary>
              Create a tree node from Token object; for CommonTree type trees,
              then the token just becomes the payload.  This is the most
              common create call.
              </summary>
            
              <remarks>
              Override if you want another kind of node to be built.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,Antlr.Runtime.IToken)">
            <summary>
              Create a new node derived from a token, with a new token type.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG[$tokenLabel].
              </summary>
            
              <remarks>
              This should invoke createToken(Token).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,Antlr.Runtime.IToken,System.String)">
            <summary>
              Same as create(tokenType,fromToken) except set the text too.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG[$tokenLabel, "IMAG"].
              </summary>
            
              <remarks>
              This should invoke createToken(Token).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(Antlr.Runtime.IToken,System.String)">
            <summary>
              Same as create(fromToken) except set the text too.
              This is invoked when the <c>text</c> terminal option is set, as in
              IMAG&lt;text='IMAG'&gt;.
              </summary>
            
              <remarks>
              This should invoke createToken(Token).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Create(System.Int32,System.String)">
            <summary>
              Create a new node derived from a token, with a new token type.
              This is invoked from an imaginary node ref on right side of a
              rewrite rule as IMAG["IMAG"].
              </summary>
            
              <remarks>
              This should invoke createToken(int,String).
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DupNode(System.Object)">
            <summary>Duplicate a single tree node.</summary>
            <remarks>Override if you want another kind of node to be built.</remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DupTree(System.Object)">
            <summary>Duplicate tree recursively, using dupNode() for each node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.Nil">
            <summary>
            Return a nil node (an empty but non-null node) that can hold
            a list of element as the children.  If you want a flat tree (a list)
            use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.ErrorNode(Antlr.Runtime.ITokenStream,Antlr.Runtime.IToken,Antlr.Runtime.IToken,Antlr.Runtime.RecognitionException)">
            <summary>
              Return a tree node representing an error.  This node records the
              tokens consumed during error recovery.  The start token indicates the
              input symbol at which the error was detected.  The stop token indicates
              the last symbol consumed during recovery.
              </summary>
            
              <remarks>
              You must specify the input stream so that the erroneous text can
              be packaged up in the error node.  The exception could be useful
              to some applications; default implementation stores ptr to it in
              the CommonErrorNode.
            
              This only makes sense during token parsing, not tree parsing.
              Tree parsing should happen only when parsing and tree construction
              succeed.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.IsNil(System.Object)">
            <summary>Is tree considered a nil node used to make lists of child nodes?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.AddChild(System.Object,System.Object)">
            <summary>
            Add a child to the tree t.  If child is a flat tree (a list), make all
            in list children of t.  Warning: if t has no children, but child does
            and child isNil then you can decide it is ok to move children to t via
            t.children = child.children; i.e., without copying the array.  Just
            make sure that this is consistent with have the user will build
            ASTs.  Do nothing if t or child is null.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.BecomeRoot(System.Object,System.Object)">
            <summary>
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <remarks>
                old=^(nil a b c), new=r yields ^(r a b c)
                old=^(a b c), new=r yields ^(r ^(a b c))
            
              If newRoot is a nil-rooted single child tree, use the single
              child as the new root node.
            
                old=^(nil a b c), new=^(nil r) yields ^(r a b c)
                old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
            
              If oldRoot was null, it's ok, just return newRoot (even if isNil).
            
                old=null, new=r yields r
                old=null, new=^(nil r) yields ^(nil r)
            
              Return newRoot.  Throw an exception if newRoot is not a
              simple node or nil root with a single child node--it must be a root
              node.  If newRoot is ^(nil x) return x as newRoot.
            
              Be advised that it's ok for newRoot to point at oldRoot's
              children; i.e., you don't have to copy the list.  We are
              constructing these nodes so we should have this control for
              efficiency.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.RulePostProcessing(System.Object)">
            <summary>
              Given the root of the subtree created for this rule, post process
              it to do any simplifications or whatever you want.  A required
              behavior is to convert ^(nil singleSubtree) to singleSubtree
              as the setting of start/stop indexes relies on a single non-nil root
              for non-flat trees.
              </summary>
            
              <remarks>
              Flat trees such as for lists like "idlist : ID+ ;" are left alone
              unless there is only one ID.  For a list, the start/stop indexes
              are set in the nil node.
            
              This method is executed after all rule tree construction and right
              before setTokenBoundaries().
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetUniqueID(System.Object)">
            <summary>For identifying trees.</summary>
            
              <remarks>
              How to identify nodes so we can say "add node to a prior node"?
              Even becomeRoot is an issue.  Use System.identityHashCode(node)
              usually.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.BecomeRoot(Antlr.Runtime.IToken,System.Object)">
            <summary>
              Create a node for newRoot make it the root of oldRoot.
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <returns>
              Return node created for newRoot.
              </returns>
            
              <remarks>
              Be advised: when debugging ASTs, the DebugTreeAdaptor manually
              calls create(Token child) and then plain becomeRoot(node, node)
              because it needs to trap calls to create, but it can't since it delegates
              to not inherits from the TreeAdaptor.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetType(System.Object)">
            <summary>For tree parsing, I need to know the token type of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetType(System.Object,System.Int32)">
            <summary>Node constructors can set the type of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetText(System.Object,System.String)">
            <summary>Node constructors can set the text of a node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetToken(System.Object)">
            <summary>
            Return the token object from which this node was created.
            Currently used only for printing an error message.
            The error display routine in BaseRecognizer needs to
            display where the input the error occurred. If your
            tree of limitation does not store information that can
            lead you to the token, you can create a token filled with
            the appropriate information and pass that back.  See
            BaseRecognizer.getErrorMessage().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetTokenBoundaries(System.Object,Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Where are the bounds in the input token stream for this node and
            all children?  Each rule that creates AST nodes will call this
            method right before returning.  Flat trees (i.e., lists) will
            still usually have a nil root node just to hold the children list.
            That node would contain the start/stop indexes then.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetTokenStartIndex(System.Object)">
            <summary>Get the token start index for this subtree; return -1 if no such index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetTokenStopIndex(System.Object)">
            <summary>Get the token stop index for this subtree; return -1 if no such index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChild(System.Object,System.Int32)">
            <summary>Get a child 0..n-1 node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.SetChild(System.Object,System.Int32,System.Object)">
            <summary>Set ith child (0..n-1) to t; t must be non-null and non-nil node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.DeleteChild(System.Object,System.Int32)">
            <summary>Remove ith child and shift children down from right.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChildCount(System.Object)">
            <summary>How many children?  If 0, then this is a leaf node</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetParent(System.Object)">
            <summary>
            Who is the parent node of this node; if null, implies node is root.
            If your node type doesn't handle this, it's ok but the tree rewrites
            in tree parsers need this functionality.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.GetChildIndex(System.Object)">
            <summary>
            What index is this node in the child list? Range: 0..n-1
            If your node type doesn't handle this, it's ok but the tree rewrites
            in tree parsers need this functionality.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeAdaptor.ReplaceChildren(System.Object,System.Int32,System.Int32,System.Object)">
            <summary>
              Replace from start to stop child index of parent with t, which might
              be a list.  Number of children may be different after this call.
              </summary>
            
              <remarks>
              If parent is null, don't do anything; must be at root of overall tree.
              Can't replace whatever points to the parent externally.  Do nothing.
              </remarks>
        </member>
        <member name="F:Antlr.Runtime.Tree.BaseTreeAdaptor.treeToUniqueIDMap">
            <summary>
            System.identityHashCode() is not always unique; we have to
            track ourselves.  That's ok, it's only for debugging, though it's
            expensive: we have to create a hashtable with all tree nodes in it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.ErrorNode(Antlr.Runtime.ITokenStream,Antlr.Runtime.IToken,Antlr.Runtime.IToken,Antlr.Runtime.RecognitionException)">
            <summary>
              Create tree node that holds the start and stop tokens associated
              with an error.
              </summary>
            
              <remarks>
              If you specify your own kind of tree nodes, you will likely have to
              override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
              if no token payload but you might have to set token type for diff
              node type.
            
              You don't have to subclass CommonErrorNode; you will likely need to
              subclass your own tree node class to avoid class cast exception.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.DupTree(System.Object,System.Object)">
            <summary>
            This is generic in the sense that it will work with any kind of
            tree (not just ITree interface).  It invokes the adaptor routines
            not the tree node routines to do the construction.  
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.AddChild(System.Object,System.Object)">
            <summary>
            Add a child to the tree t.  If child is a flat tree (a list), make all
            in list children of t.  Warning: if t has no children, but child does
            and child isNil then you can decide it is ok to move children to t via
            t.children = child.children; i.e., without copying the array.  Just
            make sure that this is consistent with have the user will build
            ASTs.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.BecomeRoot(System.Object,System.Object)">
            <summary>
              If oldRoot is a nil root, just copy or move the children to newRoot.
              If not a nil root, make oldRoot a child of newRoot.
              </summary>
            
              <remarks>
                old=^(nil a b c), new=r yields ^(r a b c)
                old=^(a b c), new=r yields ^(r ^(a b c))
            
              If newRoot is a nil-rooted single child tree, use the single
              child as the new root node.
            
                old=^(nil a b c), new=^(nil r) yields ^(r a b c)
                old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
            
              If oldRoot was null, it's ok, just return newRoot (even if isNil).
            
                old=null, new=r yields r
                old=null, new=^(nil r) yields ^(nil r)
            
              Return newRoot.  Throw an exception if newRoot is not a
              simple node or nil root with a single child node--it must be a root
              node.  If newRoot is ^(nil x) return x as newRoot.
            
              Be advised that it's ok for newRoot to point at oldRoot's
              children; i.e., you don't have to copy the list.  We are
              constructing these nodes so we should have this control for
              efficiency.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.RulePostProcessing(System.Object)">
            <summary>Transform ^(nil x) to x and nil to null</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.CreateToken(System.Int32,System.String)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.CreateToken(Antlr.Runtime.IToken)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              This is a variant of createToken where the new token is derived from
              an actual real input token.  Typically this is for converting '{'
              tokens to BLOCK etc...  You'll see
            
                r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
            
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.DupNode(System.Object)">
            <summary>
              Duplicate a node.  This is part of the factory;
              override if you want another kind of node to be built.
              </summary>
            
              <remarks>
              I could use reflection to prevent having to override this
              but reflection is slow.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.BaseTreeAdaptor.SetTokenBoundaries(System.Object,Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Track start/stop token for subtree root created for a rule.
            Only works with Tree nodes.  For rules that match nothing,
            seems like this will yield start=i and stop=i-1 in a nil node.
            Might be useful info so I'll not force to be i..i.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SessionVariableIdentifierTokenItem">
            <summary>
            系统变量标识符。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.EnField">
            <summary>
            英文名称
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.ChField">
            <summary>
            中文名称
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.Type">
            <summary>
            数据类型
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.Description">
            <summary>
            参数描述
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.HelpID">
            <summary>
            普通帮助ID
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.HelpCode">
            <summary>
            普通帮助Code
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.SmartHelpID">
            <summary>
            智能帮助ID
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.IsDynamic">
            <summary>
            是否动态
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.IsMustInput">
            <summary>
            是否必输
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionParameter.FiledType">
            <summary>
            字段的类型(字段名称，字段值)
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ConsoleNoChars">
            <summary>
              查找类似 Nn 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ConsoleYesChars">
            <summary>
              查找类似 Yy 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrAmbigGrammarRR">
            <summary>
              查找类似 Ambiguous grammar, unresolvable reduce-reduce conflicts. State {0}, lookaheads [{1}] 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrAmbigGrammarSR">
            <summary>
              查找类似 Ambiguous grammar, unresolvable shift-reduce conflicts. State {0}, lookaheads [{1}] 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrArgListNotFound">
            <summary>
              查找类似 Argument list not found in the stack. Expected: ValueList, found: {0}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrAssignLiteralValue">
            <summary>
              查找类似 Invalide operation, attempt to assign constant or literal value. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrBadChar">
            <summary>
              查找类似 Invalid length of char literal - should be a single character. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrBadStrLiteral">
            <summary>
              查找类似 Mal-formed  string literal - cannot find termination symbol. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrBadUnEscape">
            <summary>
              查找类似 Invalid unicode escape ({0}), expected {1} hex digits. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrBadXEscape">
            <summary>
              查找类似 Invalid \x escape, at least one digit expected. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrCannotConvertValue">
            <summary>
              查找类似 Cannot convert value from type {0} to type {1}, type converter not defined. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrCannotConvertValueToType">
            <summary>
              查找类似 Cannot convert literal {0} to type {1}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrConflictMsgTemplate">
            <summary>
              查找类似 {0} State {1} on inputs: {2} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrConsoleFatalError">
            <summary>
              查找类似 Fatal error: 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrConstructNotSupported">
            <summary>
              查找类似 Construct &apos;{0}&apos; is not supported (yet) by language implementation. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrDsvNoClosingQuote">
            <summary>
              查找类似 Could not find a closing quote for quoted value. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrDupRegexSwitch">
            <summary>
              查找类似 Duplicate switch &apos;{0}&apos; for regular expression. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrDupStartSymbolStr">
            <summary>
              查找类似 Duplicate start symbol {0} in string literal [{1}]. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrFailedCreateNode">
            <summary>
              查找类似 Failed to create AST node for non-terminal [{0}], error: {1} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrImpliedOpUseParserLink">
            <summary>
              查找类似 ImpliedSymbolTerminal cannot be used in grammar with DisableScannerParserLink flag set 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInternalErrDataPopFailed">
            <summary>
              查找类似 Interpreter error, DataStack.Pop() operation failed - stack is empty. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInterpreterIsBusy">
            <summary>
              查找类似 Interpreter is busy. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvalidArgsForIncDec">
            <summary>
              查找类似 Invalid arguments for IncDecNode AST node: either first or second argument should be &apos;--&apos; or &apos;++&apos;. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvalidAstMode">
            <summary>
              查找类似 Invalid AstMode value in call to Evaluate method. Node: {0}, mode: {1}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvalidChar">
            <summary>
              查找类似 Invalid character: &apos;{0}&apos;. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvalidEmbeddedPrefix">
            <summary>
              查找类似 Invalid embedded expression.  的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvDedent">
            <summary>
              查找类似 Invalid dedent level, no previous matching indent found. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvEscape">
            <summary>
              查找类似 Invalid escape sequence: \{0}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvEscSeq">
            <summary>
              查找类似 Invalid escape sequence. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvEscSymbol">
            <summary>
              查找类似 Invalid escape symbol, expected &apos;u&apos; or &apos;U&apos; only. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvNumber">
            <summary>
              查找类似 Invalid number. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvRegexSwitch">
            <summary>
              查找类似 Invalid switch &apos;{0}&apos; for regular expression 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrInvStrDef">
            <summary>
              查找类似 Error in string literal [{0}]: No start/end symbols specified. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrLastTermOfErrorProd">
            <summary>
              查找类似 The last term of production containing SyntaxError must be a terminal. NonTerminal: {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrListCannotBeTransient">
            <summary>
              查找类似 List non-terminals cannot be marked transient; list: ({0}) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNLALRhang">
            <summary>
              查找类似 NLALR process is in indefinite loop, number of states exceeded 3000. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNodeTypeNotSetOn">
            <summary>
              查找类似 Warning: AstNodeType or AstNodeCreator is not set on non-terminals: {0}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNoEndForRegex">
            <summary>
              查找类似 No end symbol for regex literal. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNoEndTagInEmbExpr">
            <summary>
              查找类似 No ending tag &apos;{0}&apos; found in embedded expression. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNoImplForUnaryOp">
            <summary>
              查找类似 UnExprNode: no implementation for unary operator &apos;{0}&apos;. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNoLetterAfterNum">
            <summary>
              查找类似 Number cannot be followed by a letter. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNoLkhds">
            <summary>
              查找类似 ParserDataBuilder error: inadequate state {0}, reduce item &apos;{1}&apos; has no lookaheads. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNtRuleIsNull">
            <summary>
              查找类似 Non-terminal {0} has uninitialized Rule property. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrNullNodeEval">
            <summary>
              查找类似 Attempt to evaluate NULL AST node. The AST node for term &apos;{0}&apos; was not created during parsing. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrOpNotDefinedForTypes">
            <summary>
              查找类似 Operator &apos;{0}&apos; is not defined for types {1} and {2}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrOpNotImplemented">
            <summary>
              查找类似 Operator &apos;{0} not imlemented. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrOutErrorPrintFormat">
            <summary>
              查找类似 {0}: {1} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrOutlineFilterContSymbol">
            <summary>
              查找类似 CodeOutlineFilter: line continuation symbol &apos;{0}&apos; should be added to Grammar.NonGrammarTerminals list. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrParserUnexpInput">
            <summary>
              查找类似 语法错误，expected: {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrParseTreeNull">
            <summary>
              查找类似 Parsed tree is null, cannot evaluate. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrParseTreeRootNull">
            <summary>
              查找类似 Parse tree root is null, cannot evaluate. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrRootAstNodeNull">
            <summary>
              查找类似 Root AST node is null, cannot evaluate. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrRootAstNoInterface">
            <summary>
              查找类似 Root AST node does not implement IInterpretedAstNode interface, cannot evaluate. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrRootNotRegistered">
            <summary>
              查找类似 ({0}) term passed as &apos;root&apos; paramater to parserr is not Root or snippet root of the grammar. Add it to SnippetRoots set in grammar constructor. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrRootNotSet">
            <summary>
              查找类似 Root property of the grammar is not set. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrRRConflict">
            <summary>
              查找类似 Reduce-reduce conflict. State {0}, lookaheads: {1}. Selected reduce on first production in conflict set. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrRuleContainsNull">
            <summary>
              查找类似 Rule for NonTerminal {0} contains null as an operand in position {1} in one of productions. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrSRConflict">
            <summary>
              查找类似 Shift-reduce conflict. State {0}, lookaheads [{1}]. Selected shift as preferred action. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrSyntaxErrorNoInfo">
            <summary>
              查找类似 语法错误。 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrTemplExprNotRoot">
            <summary>
              查找类似 Expression root non-terminal in template settings (AstNodeConfig property) in templated string literal [{0}] is not added to Roots set. Add it to SnippetRoots in grammar constructor. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrTemplMissingExprRoot">
            <summary>
              查找类似 Expression root is not specified in template settings (AstNodeConfig property) in templated string literal [{0}].  的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrTemplNoSettings">
            <summary>
              查找类似 Error in string literal [{0}]: IsTemplate flag is set, but TemplateSettings is not provided in AstNodeConfig property. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrTerminalHasEmptyPrefix">
            <summary>
              查找类似 A terminal {0} has empty prefix. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrTransientNtMustHaveOneTerm">
            <summary>
              查找类似 Transient non-terminal must have zero or one non-punctuation child nodes; non-terminals: {0}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrUnclosedComment">
            <summary>
              查找类似 未关闭的注释块。 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrUnexpEof">
            <summary>
              查找类似 Unexpected end of file. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrUnexpIndent">
            <summary>
              查找类似 Unexpected indentation. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrUnmatchedCloseBrace">
            <summary>
              查找类似 Unmatched closing brace &apos;{0}&apos;. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrVarIsNotCallable">
            <summary>
              查找类似 Variable {0} is not a callable function. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrVarNotDefined">
            <summary>
              查找类似 Variable {0} not defined. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.ErrWrongArgCount">
            <summary>
              查找类似 Invalid number of arguments. Expected {0}, found {1}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.FmtRowCol">
            <summary>
              查找类似 ({0}:{1}) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelActionAccept">
            <summary>
              查找类似 Accept 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelActionOp">
            <summary>
              查找类似 Operator, shift to {0}/reduce on {1}. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelActionReduce">
            <summary>
              查找类似 Reduce on {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelActionShift">
            <summary>
              查找类似 Shift to {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelActionUnknown">
            <summary>
              查找类似 (Unknown action type) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelEofMark">
            <summary>
              查找类似 (EOF) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelEosLabel">
            <summary>
              查找类似 [end-of-statement] 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelInitialState">
            <summary>
              查找类似 (INITIAL STATE) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelKeySymbol">
            <summary>
              查找类似 (Key symbol) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelKeyword">
            <summary>
              查找类似 (Keyword) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelLineBreak">
            <summary>
              查找类似 [line break] 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelLocation">
            <summary>
              查找类似 Location: 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelSrcHaveMore">
            <summary>
              查找类似 ... 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelUnassigned">
            <summary>
              查找类似 (unassigned) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.LabelUnnamed">
            <summary>
              查找类似 (unnamed) 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgAbortScriptYN">
            <summary>
              查找类似 Abort script(y/n)? 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgDefaultConsoleGreeting">
            <summary>
              查找类似 {0} Console.\r\nPress Ctrl-C to exit the program.\r\n 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgDefaultConsoleTitle">
            <summary>
              查找类似 Console 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgExitConsoleYN">
            <summary>
              查找类似 Exit console (y/n)? 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgNLALRAdvice">
            <summary>
              查找类似 NLALR transform: Add WrapTail() in &apos;.&apos; position to [{0}]. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgPressAnyKeyToExit">
            <summary>
              查找类似 Press any key to end the program. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgSrcPosToString">
            <summary>
              查找类似 &quot;[{0}], at {1} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceConflictResolved">
            <summary>
              查找类似 Parsing conflict resolved in code. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceOpResolved">
            <summary>
              查找类似 Operator - resolved to {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTracePoppedState">
            <summary>
              查找类似 Popped state from stack, pushing {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceRecoverAction">
            <summary>
              查找类似 RECOVERING: {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceRecoverFailed">
            <summary>
              查找类似 FAILED TO RECOVER 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceRecoverFoundState">
            <summary>
              查找类似 RECOVERING: Found state with shift on error : {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceRecovering">
            <summary>
              查找类似 RECOVERING: popping stack, looking for state with error shift 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceRecoverReducing">
            <summary>
              查找类似 RECOVERING: Reached end of error production, reducing. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceRecoverShiftError">
            <summary>
              查找类似 RECOVERING: Shifting Error term, {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceRecoverShiftTillEnd">
            <summary>
              查找类似 RECOVERING: shifting until the end of error production. 的本地化字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Grammars.GrammarResources.MsgTraceRecoverSuccess">
            <summary>
              查找类似 RECOVERED 的本地化字符串。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext">
            <summary>
            语义化表达式解析上下文。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.DataSetDic">
            <summary>
            获取数据集字典。key:数据模型英文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.SessionVariableDic">
            <summary>
            获取系统变量字典。key:变量英文名称；value:变量值。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.ContextVariableDic">
            <summary>
            获取上下文变量字典。key:变量英文名称；value:变量值。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.EvaluatorDataViewDic">
            <summary>
            获取求值真正使用的数据视图字典。key：数据集名.表名；value：求值时真正使用的数据源。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.EvaluatorDataSourceMode">
            <summary>
            获取一个值，该值指示求值时使用何种数据源。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.RecordNotFindMode">
            <summary>
            获取一个值，该值指示当要获取数据的行号不存在时，该返回何值。该属性的默认值为返回空字符串。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.FunctionObjectInstanceDic">
            <summary>
            函数实例字典。key:实例名称； value:实例。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.MemoryModeExtendFunctionDic">
            <summary>
            内存模式函数定义字典。key:Function.InstanceName。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluatorContext.DataBaseExtendFunctionDic">
            <summary>
            数据库模式函数定义字典。key:Function.InstanceName。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.ExceptionView.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExceptionView.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExceptionView.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.IXsdFieldWizard">
            <summary>
            数据字段输入向导接口。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.IXsdFieldWizard.ShowWizard(Genersoft.Platform.SemanticExpression.Builder.XsdField)">
            <summary>
            显示向导。
            </summary>
            <param name="field">要插入的字段。</param>
            <returns>向表达式编辑框中插入的文本。</returns>
        </member>
        <member name="T:Jint.Native.JsApplyFunction">
            <summary>
            This class is used to model the function.call behaviour, which takes two arguments: this, and the parameters
            It is defined in Function.prototype so that every function can use it by default
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.NumericTextBox">
            <summary>
            只允许输入数字的 TextBox
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.NumericTextBox.#ctor">
            <summary>
            只允许输入数字的文本框
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.NumericTextBox.WndProc(System.Windows.Forms.Message@)">
            <summary>
            
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.NumericTextBox.FormatString">
            <summary>
            
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.NumericTextBox.NumericPrecision">
            <summary>
            允许输入的总位数(包括小数位数,不包括小数点)
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.NumericTextBox.NumericDigits">
            <summary>
            小数点后允许输入的位数
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.NumericTextBox.NumericNegative">
            <summary>
            是否允许负数
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.NumericTextBox.ValueInt32">
            <summary>
            获取或设置文本框字符串转换后的数值
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.NumericTextBox.ValueInt64">
            <summary>
            获取或设置文本框字符串转换后的数值
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.NumericTextBox.ValueSingle">
            <summary>
            获取或设置文本框字符串转换后的数值
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.NumericTextBox.ValueDouble">
            <summary>
            获取或设置文本框字符串转换后的数值
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.NumericTextBox.ValueDecimal">
            <summary>
            获取或设置文本框字符串转换后的数值
            </summary>
        </member>
        <member name="T:Antlr.Runtime.CharStreamState">
            <summary>
              When walking ahead with cyclic DFA or for syntactic predicates,
              we need to record the state of the input stream (char index,
              line, etc...) so that we can rewind the state after scanning ahead.
              </summary>
            
              <remarks>This is the complete state of a stream.</remarks>
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.p">
            <summary>Index into the char stream of next lookahead char</summary> 
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.line">
            <summary>What line number is the scanner at before processing buffer[p]?</summary> 
        </member>
        <member name="F:Antlr.Runtime.CharStreamState.charPositionInLine">
            <summary>What char position 0..n-1 in line is scanner before processing buffer[p]?</summary> 
        </member>
        <member name="T:Antlr.Runtime.ANTLRFileStream">
            <summary>
            This is a char buffer stream that is loaded from a file
            all at once when you construct the object.  This looks very
            much like an ANTLReader or ANTLRInputStream, but it's a special case
            since we know the exact size of the object to load.  We can avoid lots
            of data copying. 
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ANTLRStringStream">
            <summary>
            A pretty quick CharStream that pulls all data from an array
            directly.  Every method call counts in the lexer.  Java's
            strings aren't very good so I'm avoiding.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer</summary> 
        </member>
        <member name="T:Antlr.Runtime.IIntStream">
            <summary>
            A simple stream of integers used when all I care about is the char
            or token type sequence (such as interpretation).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.LA(System.Int32)">
            <summary>
            Get int at current input pointer + i ahead where i=1 is next int.
            Negative indexes are allowed.  LA(-1) is previous token (token
            just matched).  LA(-i) where i is before first token should
            yield -1, invalid char / EOF.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Mark">
            <summary>
            Tell the stream to start buffering if it hasn't already.  Return
            current input position, Index, or some other marker so that
            when passed to rewind() you get back to the same spot.
            rewind(mark()) should not affect the input cursor.  The Lexer
            track line/col info as well as input index so its markers are
            not pure input indexes.  Same for tree node streams.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Rewind(System.Int32)">
            <summary>
            Reset the stream so that next call to index would return marker.
            The marker will usually be Index but it doesn't have to be.  It's
            just a marker to indicate what state the stream was in.  This is
            essentially calling release() and seek().  If there are markers
            created after this marker argument, this routine must unroll them
            like a stack.  Assume the state the stream was in when this marker
            was created.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Rewind">
            <summary>
            Rewind to the input position of the last marker.
            Used currently only after a cyclic DFA and just
            before starting a sem/syn predicate to get the
            input position back to the start of the decision.
            Do not "pop" the marker off the state.  mark(i)
            and rewind(i) should balance still. It is
            like invoking rewind(last marker) but it should not "pop"
            the marker off.  It's like seek(last marker's input position).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            You may want to commit to a backtrack but don't want to force the
            stream to keep bookkeeping objects around for a marker that is
            no longer necessary.  This will have the same behavior as
            rewind() except it releases resources without the backward seek.
            This must throw away resources for all markers back to the marker
            argument.  So if you're nested 5 levels of mark(), and then release(2)
            you have to release resources for depths 2..5.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
              Set the input cursor to the position indicated by index.  This is
              normally used to seek ahead in the input stream.  No buffering is
              required to do this unless you know your stream will use seek to
              move backwards such as when backtracking.
              </summary>
            
              <remarks>
              This is different from rewind in its multi-directional
              requirement and in that its argument is strictly an input cursor (index).
            
              For char streams, seeking forward must update the stream state such
              as line number.  For seeking backwards, you will be presumably
              backtracking using the mark/rewind mechanism that restores state and
              so this method does not need to update state when seeking backwards.
            
              Currently, this method is only used for efficient backtracking using
              memoization, but in the future it may be used for incremental parsing.
            
              The index is 0..n-1.  A seek to position i means that LA(1) will
              return the ith symbol.  So, seeking to 0 means LA(1) will return the
              first element in the stream. 
              </remarks>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the symbol about to be
            read not the most recently read symbol.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.Count">
            <summary>
            Only makes sense for streams that buffer everything up probably, but
            might be useful to display the entire stream or for testing.  This
            value includes a single EOF.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IIntStream.SourceName">
            <summary>
            Where are you getting symbols from?  Normally, implementations will
            pass the buck all the way to the lexer who can ask its input stream
            for the file name or whatever.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ICharStream.Substring(System.Int32,System.Int32)">
            <summary>
            For infinite streams, you don't need this; primarily I'm providing
            a useful interface for action code.  Just make sure actions don't
            use this on streams that don't support it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ICharStream.LT(System.Int32)">
            <summary>
            Get the ith character of lookahead.  This is the same usually as
            LA(i).  This will be used for labels in the generated
            lexer code.  I'd prefer to return a char here type-wise, but it's
            probably better to be 32-bit clean and be consistent with LA.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ICharStream.Line">
            <summary>ANTLR tracks the line information automatically</summary> 
            <summary>Because this stream can rewind, we need to be able to reset the line</summary> 
        </member>
        <member name="P:Antlr.Runtime.ICharStream.CharPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.data">
            <summary>The data being scanned</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.n">
            <summary>How many characters are actually in the buffer</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.p">
            <summary>0..n-1 index into string of next char</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.line">
            <summary>line number 1..n within the input</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.charPositionInLine">
            <summary>The index of the character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.markDepth">
            <summary>tracks how deep mark() calls are nested</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.markers">
            <summary>
            A list of CharStreamState objects that tracks the stream state
            values line, charPositionInLine, and p that can change as you
            move through the input stream.  Indexed from 1..markDepth.
            A null is kept @ index 0.  Create upon first call to mark().
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.ANTLRStringStream.name">
            <summary>What is name or source of this char stream?</summary> 
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor(System.String)">
            <summary>Copy data in string to a local char array</summary> 
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.#ctor(System.Char[],System.Int32)">
            <summary>This is the preferred constructor as no data is copied</summary> 
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Reset">
            <summary>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ANTLRStringStream.Seek(System.Int32)">
            <summary>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ANTLRStringStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the index of char to
            be returned from LA(1).
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.TokenItemDictionary">
            <summary>
            以语义化名称为键值的词法单元字典。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SemanticResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.BuiltinFunctions">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;ExpressionConfig&gt;
              &lt;MemoryMode&gt;
                &lt;Operator name=&quot;Functions&quot;&gt;
                  &lt;Functions name=&quot;内置 - 日期时间&quot;&gt;
                    &lt;Function chName=&quot;比较2个时间&quot; enName=&quot;CompareDate&quot; instanceName=&quot;DefaultFunction&quot; description=&quot;{\rtf1\fbidis\ansi\ansicpg936\deff0{\fonttbl{\f0\fnil\fprq2\fcharset134 \&apos;cb\&apos;ce\&apos;cc\&apos;e5;}{\f1\froman\fprq2\fcharset0 Times New Roman;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\fnil\fcharset134 \&apos;cb\&apos;ce\&apos;cc\&apos;e5;}}&amp;#xD;&amp;#xA;{\colortbl ;\red128\green64\blue64;\red0\green1 [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.DefaultJSFunctions">
             <summary>
               Looks up a localized string similar to function Sum()
            {
                var objfunc = DefaultFunction.GetJavaScriptTransferFunction();
                objfunc.Reset();
                for (i = 0; i &lt; arguments.length; i++)
                {
                    objfunc.PushParas(arguments[i]);
                }
                return objfunc.SumNumber();
            }
            
            function isNumber(oNum)
            {
                if (!oNum) return false;
                var strP = /^\d+(\.\d+)?$/;
                if (!strP.test(oNum)) return false;
                try
                {
                    if (parseFloat(oNum) != oNum) return false;
                }
                catch (ex)
                {
                    return false;
                }
                 [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.DialogBoxCaption_Error">
            <summary>
              Looks up a localized string similar to 语义化表达式错误.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.DialogBoxCaption_Infomation">
            <summary>
              Looks up a localized string similar to 语义化表达式信息.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.DialogBoxCaption_InfomationQuestion">
            <summary>
              Looks up a localized string similar to 语义化表达式提示.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.DialogBoxCaption_Warning">
            <summary>
              Looks up a localized string similar to 语义化表达式警告.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.DialogBoxCaption_WarningQuestion">
            <summary>
              Looks up a localized string similar to 语义化表达式警告.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_btnAotoHideToolTipText">
            <summary>
              Looks up a localized string similar to 自动隐藏.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_btnCloseToolTipText">
            <summary>
              Looks up a localized string similar to 关闭.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_btnLayoutToolTipText">
            <summary>
              Looks up a localized string similar to 排列窗口.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_btnMinToolTipText">
            <summary>
              Looks up a localized string similar to 最小化.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_btnRestoreToolTipText">
            <summary>
              Looks up a localized string similar to 往下还原.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_layoutCascadeItemText">
            <summary>
              Looks up a localized string similar to 层叠(&amp;C).
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_layoutCloseAllItemText">
            <summary>
              Looks up a localized string similar to 关闭所有窗口(&amp;L).
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_layoutTileHorizontalItemText">
            <summary>
              Looks up a localized string similar to 水平平铺(&amp;H).
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Docking_layoutTileVerticalItemText">
            <summary>
              Looks up a localized string similar to 垂直平铺(&amp;V).
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_DataBaseTypeUnspecified">
            <summary>
              Looks up a localized string similar to 数据库表达式必须明确指定适用的数据库类型。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_FileNotFound_FuncAssembly">
            <summary>
              Looks up a localized string similar to 在当前环境中，找不到扩展函数 {0} 解析时所需要的程序集文件 {1}.dll。如果您正在使用调试功能，则极有可能此扩展函数是运行在服务器端的，无法在客户端对其进行调试。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_NotFound_ContextVariable">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器上下文中，找不到名称为 {0} 的上下文变量。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_NotFound_DataSet">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器上下文中，找不到名称为 {0} 的数据集。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_NotFound_Field">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器上下文中，数据集 {0} 的表 {1} 中不包含名称为 {2} 的字段。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_NotFound_FuncInstance">
            <summary>
              Looks up a localized string similar to 在扩展函数配置文件中，找不到实例名称为 {0} 的函数定义。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_NotFound_RowNumber">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器上下文中，数据集 {0} 的表 {1}，不包含行号为 {2} 的记录。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_NotFound_SessionVariable">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器上下文中，找不到名称为 {0} 的系统变量。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_NotFound_SubExpression">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器上下文中，找不到名称为 {0} 的子表达式。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_NotFound_Table">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器上下文中，数据集 {0} 中不包含名称为 {1} 的表。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_RepeatAddContextVariable">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器中，已经添加了名称为 {0} 的上下文变量。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_RepeatAddDataSet">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器中，已经添加了名称为 {0} 的数据集。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_RepeatAddObject">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器中，已经添加了名称为 {0} 的解析对象。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_RepeatAddSessionVariable">
            <summary>
              Looks up a localized string similar to 语义化表达式解析器中，已经添加了名称为 {0} 的系统变量。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_Evaluator_ScriptControlEval">
            <summary>
              Looks up a localized string similar to 调用 JavaScript 解析引擎，对语义化表达式进行求值时，发生了异常。异常信息：.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_ExpressionText_Empty">
            <summary>
              Looks up a localized string similar to 表达式为空。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_ExpressionText_Invaldate">
            <summary>
              Looks up a localized string similar to 文本不是有效的语义化表达式格式。文本：{0}.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_GrammarParser_InvaldateIdentifier">
            <summary>
              Looks up a localized string similar to 在当前表达式上下文中，找不到语义化名称为 {0} 的变量、函数或字段。 .
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_GrammarParser_null">
            <summary>
              Looks up a localized string similar to 语法解析器为空，不能进行语法解析，请首先正确初始化表达式上下文。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_GrammarParser_Verify">
            <summary>
              Looks up a localized string similar to 语法校验失败。在第 {0} 行、第 {1} 列附近发生了错误。{2}.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_IFunctionWizard">
            <summary>
              Looks up a localized string similar to 函数向导必须是实现 IFunctionWizard 接口的类。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_ISmartHelpWizard">
            <summary>
              Looks up a localized string similar to 智能帮助向导必须是实现 ISmartHelpWizard 接口的类。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_KeyName_CnNameIsNullOrWhiteSpace">
            <summary>
              Looks up a localized string similar to {0}{1}语义化名称为空，不符合规范。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_KeyName_EnNameIsNullOrWhiteSpace">
            <summary>
              Looks up a localized string similar to {0}{1}英文名称为空，不符合规范。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_KeyName_RepeatCnName">
            <summary>
              Looks up a localized string similar to {0}{1}，与已添加的{2}{3}，语义化名称相同。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_KeyName_RepeatEnName">
            <summary>
              Looks up a localized string similar to {0}{1}，与已添加的{2}{3}，英文名称相同。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_LocalVariable_Equal">
            <summary>
              Looks up a localized string similar to 赋值运算符“=”只能应用于局部变量。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_LocalVariable_RepeatName">
            <summary>
              Looks up a localized string similar to 已经定义了名称为 {0} 的局部变量。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_LocalVariable_RepeatNameId">
            <summary>
              Looks up a localized string similar to 已经定义了名称为 {0} 的{1}，此名称不能再用作局部变量。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_ResetExpressionText">
            <summary>
              Looks up a localized string similar to 在没有初始化表达式上下文之前，不能设置表达式文本。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_SubExpression">
            <summary>
              Looks up a localized string similar to 子表达式{0}不是有效的语义化表达式。定义文本：{1}.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_XsdField_RepeatCnName">
            <summary>
              Looks up a localized string similar to 数据模型 {0} 的表 {1}，存在相同的中文字段名：{2}。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_XsdField_RepeatEnName">
            <summary>
              Looks up a localized string similar to 数据模型 {0} 的表 {1}，存在相同的英文字段名：{2}。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_XsdTable_RepeatCnName">
            <summary>
              Looks up a localized string similar to 数据模型 {0} 中已存在语义化名称为 {1} 的表。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Err_XsdTable_RepeatEnName">
            <summary>
              Looks up a localized string similar to 数据模型 {0} 中已存在英文名称为 {1} 的表。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.FormFindInDataGridView_FindAllResult">
            <summary>
              Looks up a localized string similar to 共找到 {0} 个匹配单元格。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.FormFindInDataGridView_InputFindText">
            <summary>
              Looks up a localized string similar to 请输入查找内容！.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.FormFindInDataGridView_NotFindText">
            <summary>
              Looks up a localized string similar to 没有找到要查找的内容！.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Info_GrammarParser_VerifyValidate">
            <summary>
              Looks up a localized string similar to 语法校验通过。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Info_NotFoundHelpFile">
            <summary>
              Looks up a localized string similar to 未找到帮助文件 语义化表达式参考手册.chm。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Info_NotSupport_SaveAsSubExpression">
            <summary>
              Looks up a localized string similar to 调用语义化表达式编辑器的模块，没有实现另存为子表达式的保存逻辑。.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Char">
            <summary>
              Looks up a localized string similar to 字符.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_CnFieldName">
            <summary>
              Looks up a localized string similar to 中文字段名.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_CnName">
            <summary>
              Looks up a localized string similar to 语义化名称.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Column">
            <summary>
              Looks up a localized string similar to 列.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Constant">
            <summary>
              Looks up a localized string similar to 常量.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_ContextVariable">
            <summary>
              Looks up a localized string similar to 上下文变量.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_CursorOffset">
            <summary>
              Looks up a localized string similar to 插入点偏移量.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_DataType">
            <summary>
              Looks up a localized string similar to 数据类型.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Delimiter">
            <summary>
              Looks up a localized string similar to 分隔符.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Design_AssmblyName">
            <summary>
              Looks up a localized string similar to 设计向导程序集.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Design_ClassFullName">
            <summary>
              Looks up a localized string similar to 设计向导类完全限定名.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_EnFieldName">
            <summary>
              Looks up a localized string similar to 英文字段名.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_EnName">
            <summary>
              Looks up a localized string similar to 英文名称.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Error">
            <summary>
              Looks up a localized string similar to 错误.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Eva_AssmblyName">
            <summary>
              Looks up a localized string similar to 解析程序集.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Eva_ClassFullName">
            <summary>
              Looks up a localized string similar to 解析类完全限定名.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Eva_InstanceName">
            <summary>
              Looks up a localized string similar to 解析类实例名称.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Exception">
            <summary>
              Looks up a localized string similar to 异常.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Exception_HelpLink">
            <summary>
              Looks up a localized string similar to 帮助.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Exception_InnerException">
            <summary>
              Looks up a localized string similar to 内部异常.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Exception_Message">
            <summary>
              Looks up a localized string similar to 消息.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Exception_Source">
            <summary>
              Looks up a localized string similar to 对象.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Exception_StackTrace">
            <summary>
              Looks up a localized string similar to 堆栈.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Exception_Type">
            <summary>
              Looks up a localized string similar to 类型.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_ExpressionConfig">
            <summary>
              Looks up a localized string similar to 配置文件.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Field">
            <summary>
              Looks up a localized string similar to 字段.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_FieldName">
            <summary>
              Looks up a localized string similar to 字段名.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Font">
            <summary>
              Looks up a localized string similar to 字体.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Function">
            <summary>
              Looks up a localized string similar to 函数.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Function_Category">
            <summary>
              Looks up a localized string similar to 分类名称.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Function_Decription">
            <summary>
              Looks up a localized string similar to 使用帮助.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Function_ExpressionCategory">
            <summary>
              Looks up a localized string similar to 适用表达式.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Identifier">
            <summary>
              Looks up a localized string similar to 标识符.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Info">
            <summary>
              Looks up a localized string similar to 信息.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_InsertText">
            <summary>
              Looks up a localized string similar to 插入文本.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_IsParamsMethod">
            <summary>
              Looks up a localized string similar to 可变参数方法.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_KeyTerm">
            <summary>
              Looks up a localized string similar to 词法单元.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Keyword">
            <summary>
              Looks up a localized string similar to 关键字.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Line">
            <summary>
              Looks up a localized string similar to 行.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_MssName">
            <summary>
              Looks up a localized string similar to Mss名称.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Operator">
            <summary>
              Looks up a localized string similar to 运算符.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_OraName">
            <summary>
              Looks up a localized string similar to Ora名称.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Parameter">
            <summary>
              Looks up a localized string similar to 参数.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Position">
            <summary>
              Looks up a localized string similar to 位置.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_SemanticExpression">
            <summary>
              Looks up a localized string similar to 语义化表达式.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Sequence">
            <summary>
              Looks up a localized string similar to 序号.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_SessionVariable">
            <summary>
              Looks up a localized string similar to 系统变量.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_SmartHelpName">
            <summary>
              Looks up a localized string similar to 智能帮助名称.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_SmartHelpTag">
            <summary>
              Looks up a localized string similar to 自定义标记.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_SubExpression">
            <summary>
              Looks up a localized string similar to 子表达式.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_SyntaxError">
            <summary>
              Looks up a localized string similar to 语法错误.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_ToolTip">
            <summary>
              Looks up a localized string similar to 提示文本.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Value">
            <summary>
              Looks up a localized string similar to 值.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Variable">
            <summary>
              Looks up a localized string similar to 变量.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_Warning">
            <summary>
              Looks up a localized string similar to 警告.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_XmlSchema">
            <summary>
              Looks up a localized string similar to 数据模型.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_XsdField">
            <summary>
              Looks up a localized string similar to 数据字段.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Term_XsdTable">
            <summary>
              Looks up a localized string similar to 数据表.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Tip_Ready">
            <summary>
              Looks up a localized string similar to 就绪.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Tip_ResetExpressionContext">
            <summary>
              Looks up a localized string similar to 正在初始化表达式上下文....
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Warn_ChoseExpressionDesignerQuestion">
            <summary>
              Looks up a localized string similar to 确实要使用旧表达式吗？.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Warn_ResetOptionsStatus">
            <summary>
              Looks up a localized string similar to 此操作将恢复各选项到默认值。继续吗？.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticResources.Warn_SaveQuestion">
            <summary>
              Looks up a localized string similar to 表达式已被修改，需要保存吗？.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Math.BigInteger">
            <summary>
            arbitrary precision integers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.Create(System.Byte[])">
            <summary>
            Create a BigInteger from a little-endian twos-complement byte array
            (inverse of ToByteArray())
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.GetBits">
            <summary>
            Return the magnitude of this BigInteger as an array of zero or more uints.
            Element zero is the value of the least significant four bytes, element one is
            the value of the four next most significant bytes, etc.
            
            The returned data is the unsigned magnitude of the number. To determine the sign,
            use GetSign().
            
            It is guaranteed that the highest element of the returned array is never zero.
            This means that if the value of this BigInteger is zero, a zero-length array
            is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.makeTwosComplement(System.UInt32[])">
            <summary>
            Do an in-place twos complement of d and also return the result.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Math.BigInteger.ToByteArray">
            <summary>
            Return the value of this BigInteger as a little-endian twos-complement
            byte array, using the fewest number of bytes possible. If the value is zero,
            return an array of one byte whose element is 0x00.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.BigInteger.Sign">
            <summary>
            Return the sign of this BigInteger: -1, 0, or 1.
            </summary>
        </member>
        <member name="M:Jint.JintEngine.HasErrors(System.String,System.String@)">
            <summary>
            Pre-compiles the expression in order to check syntax errors.
            If errors are detected, the Error property contains the message.
            </summary>
            <returns>True if the expression syntax is correct, otherwiser False</returns>
        </member>
        <member name="M:Jint.JintEngine.Run(System.String)">
            <summary>
            Runs a set of JavaScript statements and optionally returns a value if return is called
            </summary>
            <param name="script">The script to execute</param>
            <returns>Optionaly, returns a value from the scripts</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.Security.SecurityException"/>
            <exception cref="T:Jint.JintException"/>
        </member>
        <member name="M:Jint.JintEngine.Run(Jint.Expressions.Program)">
            <summary>
            Runs a set of JavaScript statements and optionally returns a value if return is called
            </summary>
            <param name="program">The expression tree to execute</param>
            <returns>Optionaly, returns a value from the scripts</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.Security.SecurityException"/>
            <exception cref="T:Jint.JintException"/>
        </member>
        <member name="M:Jint.JintEngine.Run(System.IO.TextReader)">
            <summary>
            Runs a set of JavaScript statements and optionally returns a value if return is called
            </summary>
            <param name="reader">The TextReader to read script from</param>
            <returns>Optionaly, returns a value from the scripts</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.Security.SecurityException"/>
            <exception cref="T:Jint.JintException"/>
        </member>
        <member name="M:Jint.JintEngine.Run(System.IO.TextReader,System.Boolean)">
            <summary>
            Runs a set of JavaScript statements and optionally returns a value if return is called
            </summary>
            <param name="reader">The TextReader to read script from</param>
            <param name="unwrap">Whether to unwrap the returned value to a CLR instance. <value>True</value> by default.</param>
            <returns>Optionaly, returns a value from the scripts</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.Security.SecurityException"/>
            <exception cref="T:Jint.JintException"/>
        </member>
        <member name="M:Jint.JintEngine.Run(System.String,System.Boolean)">
            <summary>
            Runs a set of JavaScript statements and optionally returns a value if return is called
            </summary>
            <param name="script">The script to execute</param>
            <param name="unwrap">Whether to unwrap the returned value to a CLR instance. <value>True</value> by default.</param>
            <returns>Optionaly, returns a value from the scripts</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.Security.SecurityException"/>
            <exception cref="T:Jint.JintException"/>
        </member>
        <member name="M:Jint.JintEngine.Run(Jint.Expressions.Program,System.Boolean)">
            <summary>
            Runs a set of JavaScript statements and optionally returns a value if return is called
            </summary>
            <param name="program">The expression tree to execute</param>
            <param name="unwrap">Whether to unwrap the returned value to a CLR instance. <value>True</value> by default.</param>
            <returns>Optionaly, returns a value from the scripts</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.Security.SecurityException"/>
            <exception cref="T:Jint.JintException"/>
        </member>
        <member name="M:Jint.JintEngine.SetMaxRecursions(System.Int32)">
            <summary>
            Defines the max allowed number of recursions in the script
            </summary>
        </member>
        <member name="M:Jint.JintEngine.SetParameter(System.String,System.Object)">
            <summary>
            Defines an external object to be available inside the script
            </summary>
            <param name="name">Local name of the object duting the execution of the script</param>
            <param name="value">Available object</param>
            <returns>The current JintEngine instance</returns>
        </member>
        <member name="M:Jint.JintEngine.SetParameter(System.String,System.Double)">
            <summary>
            Defines an external Double value to be available inside the script
            </summary>
            <param name="name">Local name of the Double value during the execution of the script</param>
            <param name="value">Available Double value</param>
            <returns>The current JintEngine instance</returns>
        </member>
        <member name="M:Jint.JintEngine.SetParameter(System.String,System.String)">
            <summary>
            Defines an external String instance to be available inside the script
            </summary>
            <param name="name">Local name of the String instance during the execution of the script</param>
            <param name="value">Available String instance</param>
            <returns>The current JintEngine instance</returns>
        </member>
        <member name="M:Jint.JintEngine.SetParameter(System.String,System.Int32)">
            <summary>
            Defines an external Int32 value to be available inside the script
            </summary>
            <param name="name">Local name of the Int32 value during the execution of the script</param>
            <param name="value">Available Int32 value</param>
            <returns>The current JintEngine instance</returns>
        </member>
        <member name="M:Jint.JintEngine.SetParameter(System.String,System.Boolean)">
            <summary>
            Defines an external Boolean value to be available inside the script
            </summary>
            <param name="name">Local name of the Boolean value during the execution of the script</param>
            <param name="value">Available Boolean value</param>
            <returns>The current JintEngine instance</returns>
        </member>
        <member name="M:Jint.JintEngine.SetParameter(System.String,System.DateTime)">
            <summary>
            Defines an external DateTime value to be available inside the script
            </summary>
            <param name="name">Local name of the DateTime value during the execution of the script</param>
            <param name="value">Available DateTime value</param>
            <returns>The current JintEngine instance</returns>
        </member>
        <member name="M:Jint.JintEngine.EscapteStringLiteral(System.String)">
            <summary>
            Escapes a JavaScript string literal
            </summary>
            <param name="value">The string literal to espace</param>
            <returns>The escaped string literal, without sinlge quotes, back slashes and line breaks</returns>
        </member>
        <member name="P:Jint.JintEngine.Global">
            <summary>
            A global object associated with this engine instance
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.KeyTermEditorBindingItem">
            <summary>
            关键字和运算符编辑绑定项。
            </summary>
        </member>
        <member name="T:Antlr.Runtime.UnbufferedTokenStream">
            A token stream that pulls tokens from the code source on-demand and
              without tracking a complete buffer of the tokens. This stream buffers
              the minimum number of tokens possible.  It's the same as
              OnDemandTokenStream except that OnDemandTokenStream buffers all tokens.
            
              You can't use this stream if you pass whitespace or other off-channel
              tokens to the parser. The stream can't ignore off-channel tokens.
             
              You can only look backwards 1 token: LT(-1).
            
              Use this when you need to read from a socket or other infinite stream.
            
              @see BufferedTokenStream
              @see CommonTokenStream
        </member>
        <member name="T:Antlr.Runtime.Misc.LookaheadStream`1">
            <summary>
            A lookahead queue that knows how to mark/release locations
            in the buffer for backtracking purposes. Any markers force the FastQueue
            superclass to keep all tokens until no more markers; then can reset
            to avoid growing a huge buffer.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Misc.FastQueue`1">
            A queue that can dequeue and get(i) in O(1) and grow arbitrarily large.
              A linked list is fast at dequeue but slow at get(i).  An array is
              the reverse.  This is O(1) for both operations.
            
              List grows until you dequeue last element at end of buffer. Then
              it resets to start filling at 0 again.  If adds/removes are balanced, the
              buffer will not grow too large.
            
              No iterator stuff as that's not how we'll use it.
        </member>
        <member name="F:Antlr.Runtime.Misc.FastQueue`1._data">
            <summary>dynamically-sized buffer of elements</summary> 
        </member>
        <member name="F:Antlr.Runtime.Misc.FastQueue`1._p">
            <summary>index of next element to fill</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.FastQueue`1.Dequeue">
            <summary>Get and remove first element in queue</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.FastQueue`1.ToString">
            <summary>Return string of current buffer contents; non-destructive</summary> 
        </member>
        <member name="P:Antlr.Runtime.Misc.FastQueue`1.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Misc.FastQueue`1.Item(System.Int32)">
            <summary>
            Return element i elements ahead of current element.  i==0 gets
            current element.  This is not an absolute index into the data list
            since p defines the start of the real list.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._currentElementIndex">
            Absolute token index. It's the index of the symbol about to be
            read via LT(1). Goes from 0 to numtokens.
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._eof">
            Track object returned by nextElement upon end of stream;
            Return it later when they ask for LT passed end of input.
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.Misc.LookaheadStream`1._markDepth">
            <summary>tracks how deep mark() calls are nested</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.NextElement">
            <summary>
            Implement nextElement to supply a stream of elements to this
            lookahead buffer.  Return eof upon end of the stream we're pulling from.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Dequeue">
            <summary>Get and remove first element in queue; override FastQueue.remove()</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Consume">
            <summary>Make sure we have at least one element to remove, even if EOF</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.SyncAhead(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position p. Last valid
            p index is data.size()-1.  p+need-1 is the data index 'need' elements
            ahead.  If we need 1 element, (p+1-1)==p must be &lt; data.size().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Fill(System.Int32)">
            <summary>add n elements to buffer</summary> 
        </member>
        <member name="M:Antlr.Runtime.Misc.LookaheadStream`1.Seek(System.Int32)">
            <summary>
            Seek to a 0-indexed position within data buffer.  Can't handle
            case where you seek beyond end of existing buffer.  Normally used
            to seek backwards in the buffer. Does not force loading of nodes.
            Doesn't see to absolute position in input stream since this stream
            is unbuffered. Seeks only into our moving window of elements.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Misc.LookaheadStream`1.Count">
            <summary>Size of entire stream is unknown; we only know buffer size from FastQueue</summary> 
        </member>
        <member name="T:Antlr.Runtime.ITokenStream">
            <summary>A stream of tokens accessing tokens from a TokenSource</summary> 
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.LT(System.Int32)">
            <summary>Get Token at current input pointer + i ahead where i=1 is next Token.
            i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is
            two tokens ago. LT(0) is undefined.  For i&gt;=n, return Token.EOFToken.
            Return null for LT(0) and any index that results in an absolute address
            that is negative.</summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Get a token at an absolute index i; 0..n-1.  This is really only
            needed for profiling and debugging and token stream rewriting.
            If you don't want to buffer up tokens, then this method makes no
            sense for you.  Naturally you can't use the rewrite stream feature.
            I believe DebugTokenStream can easily be altered to not use
            this method, removing the dependency.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.ToString(System.Int32,System.Int32)">
            <summary>
            Return the text of all tokens from start to stop, inclusive.
            If the stream does not buffer all the tokens then it can just
            return "" or null;  Users should not access $ruleLabel.text in
            an action of course in that case.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenStream.ToString(Antlr.Runtime.IToken,Antlr.Runtime.IToken)">
            <summary>
            Because the user is not required to use a token with an index stored
            in it, we must provide a means for two token objects themselves to
            indicate the start/end location.  Most often this will just delegate
            to the other toString(int,int).  This is also parallel with
            the TreeNodeStream.toString(Object,Object).
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenStream.Range">
            <summary>
            How far ahead has the stream been asked to look?  The return
            value is a valid index from 0..n-1.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenStream.TokenSource">
            <summary>
            Where is this stream pulling tokens from?  This is not the name, but
            the object that provides Token objects.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.UnbufferedTokenStream.channel">
            Skip tokens on any channel but this one; this is how we skip whitespace... 
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard">
            <summary>
              Build and navigate trees with this object.  Must know about the names
              of tokens so you have to pass in a map or array of token names (from which
              this class can build the map).  I.e., Token DECL means nothing unless the
              class can translate it to a token type.
              </summary>
            
              <remarks>
              In order to create nodes and navigate, this class needs a TreeAdaptor.
            
              This class can build a token type -> node index for repeated use or for
              iterating over the various nodes with a particular type.
            
              This class works in conjunction with the TreeAdaptor rather than moving
              all this functionality into the adaptor.  An adaptor helps build and
              navigate trees using methods.  This class helps you do it with string
              patterns like "(A B C)".  You can create a tree from that pattern or
              match subtrees against it.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.ComputeTokenTypes(System.String[])">
            <summary>
            Compute a Map&lt;String, Integer&gt; that is an inverted index of
            tokenNames (which maps int token types to names).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.GetTokenType(System.String)">
            <summary>Using the map of token names to token types, return the type.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Index(System.Object)">
            <summary>
              Walk the entire tree and make a node name to nodes mapping.
              For now, use recursion but later nonrecursive version may be
              more efficient.  Returns Map&lt;Integer, List&gt; where the List is
              of your AST node type.  The Integer is the token type of the node.
              </summary>
            
              <remarks>
              TODO: save this index so that find and visit are faster
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.IndexCore(System.Object,System.Collections.Generic.IDictionary{System.Int32,System.Collections.IList})">
            <summary>Do the work for index</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Find(System.Object,System.Int32)">
            <summary>Return a List of tree nodes with token type ttype</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Find(System.Object,System.String)">
            <summary>Return a List of subtrees matching pattern.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Visit(System.Object,System.Int32,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>
            Visit every ttype node in t, invoking the visitor.  This is a quicker
            version of the general visit(t, pattern) method.  The labels arg
            of the visitor action method is never set (it's null) since using
            a token type rather than a pattern doesn't let us set a label.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.VisitCore(System.Object,System.Object,System.Int32,System.Int32,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>Do the recursive work for visit</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Visit(System.Object,System.String,Antlr.Runtime.Tree.TreeWizard.IContextVisitor)">
            <summary>
            For all subtrees that match the pattern, execute the visit action.
            The implementation uses the root node of the pattern in combination
            with visit(t, ttype, visitor) so nil-rooted patterns are not allowed.
            Patterns with wildcard roots are also not allowed.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Parse(System.Object,System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
              Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels
              on the various nodes and '.' (dot) as the node/subtree wildcard,
              return true if the pattern matches and fill the labels Map with
              the labels pointing at the appropriate nodes.  Return false if
              the pattern is malformed or the tree does not match.
              </summary>
            
              <remarks>
              If a node specifies a text arg in pattern, then that must match
              for that node in t.
            
              TODO: what's a better way to indicate bad pattern? Exceptions are a hassle 
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.ParseCore(System.Object,Antlr.Runtime.Tree.TreeWizard.TreePattern,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Do the work for parse. Check to see if the t2 pattern fits the
            structure and token types in t1.  Check text if the pattern has
            text arguments on nodes.  Fill labels map with pointers to nodes
            in tree matched against nodes in pattern with labels.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Create(System.String)">
            <summary>
              Create a tree or node from the indicated tree pattern that closely
              follows ANTLR tree grammar tree element syntax:
            
                  (root child1 ... child2).
              </summary>
            
              <remarks>
              You can also just pass in a node: ID
             
              Any node can have a text argument: ID[foo]
              (notice there are no quotes around foo--it's clear it's a string).
            
              nil is a special name meaning "give me a nil node".  Useful for
              making lists: (nil A B C) is a list of A B C.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Equals(System.Object,System.Object,Antlr.Runtime.Tree.ITreeAdaptor)">
            <summary>
              Compare t1 and t2; return true if token types/text, structure match exactly.
              The trees are examined in their entirety so that (A B) does not match
              (A B C) nor (A (B C)). 
              </summary>
            
              <remarks>
              TODO: allow them to pass in a comparator
              TODO: have a version that is nonstatic so it can use instance adaptor
            
              I cannot rely on the tree node's equals() implementation as I make
              no constraints at all on the node types nor interface etc... 
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeWizard.Equals(System.Object,System.Object)">
            <summary>
            Compare type, structure, and text of two trees, assuming adaptor in
            this instance of a TreeWizard.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard.TreePattern">
            <summary>
            When using %label:TOKENNAME in a tree for parse(), we must
            track the label.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonTree">
            <summary>
            A tree node that is wrapper for a Token object.  After 3.0 release
            while building tree rewrite stuff, it became clear that computing
            parent and child index is very difficult and cumbersome.  Better to
            spend the space in every tree node.  If you don't want these extra
            fields, it's easy to cut them out in your own BaseTree subclass.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree._token">
            <summary>A single token is the payload</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.startIndex">
            <summary>
            What token indexes bracket all tokens associated with this node
            and below?
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.parent">
            <summary>Who is the parent node of this node; if null, implies node is root</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTree.childIndex">
            <summary>What index is this node in the child list? Range: 0..n-1</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTree.SetUnknownTokenBoundaries">
            <summary>
            For every node in this subtree, make sure it's start/stop token's
            are set.  Walk depth first, visit bottom up.  Only updates nodes
            with at least one token index &lt; 0.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeWizard.TreePatternTreeAdaptor">
            <summary>This adaptor creates TreePattern objects for use during scan()</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonTreeAdaptor">
            <summary>
              A TreeAdaptor that works with any Tree implementation.  It provides
              really just factory methods; all the work is done by BaseTreeAdaptor.
              If you would like to have different tokens created than ClassicToken
              objects, you need to override this and then set the parser tree adaptor to
              use your subclass.
              </summary>
            
              <remarks>
              To get your parser to build nodes of a different type, override
              create(Token), errorNode(), and to be safe, YourTreeClass.dupNode().
              dupNode is called to duplicate nodes during rewrite operations.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.CreateToken(System.Int32,System.String)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.CreateToken(Antlr.Runtime.IToken)">
            <summary>
              Tell me how to create a token for use with imaginary token nodes.
              For example, there is probably no input symbol associated with imaginary
              token DECL, but you need to create it as a payload or whatever for
              the DECL node as in ^(DECL type ID).
              </summary>
            
              <remarks>
              This is a variant of createToken where the new token is derived from
              an actual real input token.  Typically this is for converting '{'
              tokens to BLOCK etc...  You'll see
            
                r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
            
              If you care what the token payload objects' type is, you should
              override this method and any other createToken variant.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeAdaptor.GetToken(System.Object)">
            <summary>
            What is the Token associated with this node?  If
            you are not using CommonTree, then you must
            override this in your own adaptor.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.NextNode">
            <summary>Get next token from stream and make a node for it</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleTokenStream.ToTree(System.Object)">
            <summary>
            Don't convert to a tree unless they explicitly call nextTree.
            This way we can do hetero tree nodes in rewrite.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteCardinalityException">
            <summary>
            Base class for all exceptions thrown during AST rewrite construction.
            This signifies a case where the cardinality of two or more elements
            in a subrule are different: (ID INT)+ where |ID|!=|INT|
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Lexer">
            <summary>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified match() and error recovery mechanisms in the interest
            of speed.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.BaseRecognizer">
            <summary>
            A generic recognizer that can handle recognizers generated from
            lexer, parser, and tree grammars.  This is all the parsing
            support code essentially; most of it is error recovery stuff and
            backtracking.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.BaseRecognizer.state">
            <summary>
            State of a lexer, parser, or tree parser are collected into a state
            object so the state can be shared.  This sharing is needed to
            have one grammar import others and share same error variables
            and other state variables.  It's a kind of explicit multiple
            inheritance via delegation of methods and shared state.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Reset">
            <summary>reset the parser's state; subclasses must rewinds the input stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Match(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
              Match current input symbol against ttype.  Attempt
              single token insertion or deletion error recovery.  If
              that fails, throw MismatchedTokenException.
              </summary>
            
              <remarks>
              To turn off single token insertion or deletion error
              recovery, override recoverFromMismatchedToken() and have it
              throw an exception. See TreeParser.recoverFromMismatchedToken().
              This way any error in a rule will cause an exception and
              immediate exit from rule.  Rule would recover by resynchronizing
              to the set of symbols that can follow rule ref.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.MatchAny(Antlr.Runtime.IIntStream)">
            <summary>Match the wildcard: in a symbol</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ReportError(Antlr.Runtime.RecognitionException)">
            <summary>Report a recognition problem.</summary>
            
              <remarks>
              This method sets errorRecovery to indicate the parser is recovering
              not parsing.  Once in recovery mode, no errors are generated.
              To get out of recovery mode, the parser must successfully match
              a token (after a resync).  So it will go:
            
             		1. error occurs
             		2. enter recovery mode, report error
             		3. consume until token found in resynch set
             		4. try to resume parsing
             		5. next match() will reset errorRecovery mode
            
              If you override, make sure to update syntaxErrors if you care about that.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetErrorMessage(Antlr.Runtime.RecognitionException,System.String[])">
            <summary>What error message should be generated for the various exception types?</summary>
            
              <remarks>
              Not very object-oriented code, but I like having all error message
              generation within one method rather than spread among all of the
              exception classes. This also makes it much easier for the exception
              handling because the exception classes do not have to have pointers back
              to this object to access utility routines and so on. Also, changing
              the message for an exception type would be difficult because you
              would have to subclassing exception, but then somehow get ANTLR
              to make those kinds of exception objects instead of the default.
              This looks weird, but trust me--it makes the most sense in terms
              of flexibility.
            
              For grammar debugging, you will want to override this to add
              more information such as the stack frame with
              getRuleInvocationStack(e, this.getClass().getName()) and,
              for no viable alts, the decision description and state etc...
            
              Override this to change the message generated for one or more
              exception types.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetErrorHeader(Antlr.Runtime.RecognitionException)">
            <summary>What is the error header, normally line/character position information?</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetTokenErrorDisplay(Antlr.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.ToString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.EmitErrorMessage(System.String)">
            <summary>Override this method to change where error messages go</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Recover(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException)">
            <summary>
            Recover from an error found on the input stream.  This is
            for NoViableAlt and mismatched symbol exceptions.  If you enable
            single token insertion and deletion, this will usually not
            handle mismatched symbol exceptions but there could be a mismatched
            token that the match() routine could not recover from.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.BeginResync">
            <summary>
            A hook to listen in on the token consumption during error recovery.
            The DebugParser subclasses this to fire events to the listenter.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ComputeContextSensitiveRuleFOLLOW">
            <summary>
              Compute the context-sensitive FOLLOW set for current rule.
              This is set of token types that can follow a specific rule
              reference given a specific call chain.  You get the set of
              viable tokens that can possibly come next (lookahead depth 1)
              given the current call chain.  Contrast this with the
              definition of plain FOLLOW for rule r:
              </summary>
            
               FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
            
              where x in T* and alpha, beta in V*; T is set of terminals and
              V is the set of terminals and nonterminals.  In other words,
              FOLLOW(r) is the set of all tokens that can possibly follow
              references to r in *any* sentential form (context).  At
              runtime, however, we know precisely which context applies as
              we have the call chain.  We may compute the exact (rather
              than covering superset) set of following tokens.
            
              For example, consider grammar:
            
              stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
                   | "return" expr '.'
                   ;
              expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
              atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
                   | '(' expr ')'
                   ;
            
              The FOLLOW sets are all inclusive whereas context-sensitive
              FOLLOW sets are precisely what could follow a rule reference.
              For input input "i=(3);", here is the derivation:
            
              stat => ID '=' expr ';'
                   => ID '=' atom ('+' atom)* ';'
                   => ID '=' '(' expr ')' ('+' atom)* ';'
                   => ID '=' '(' atom ')' ('+' atom)* ';'
                   => ID '=' '(' INT ')' ('+' atom)* ';'
                   => ID '=' '(' INT ')' ';'
            
              At the "3" token, you'd have a call chain of
            
                stat -> expr -> atom -> expr -> atom
            
              What can follow that specific nested ref to atom?  Exactly ')'
              as you can see by looking at the derivation of this specific
              input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
            
              You want the exact viable token set when recovering from a
              token mismatch.  Upon token mismatch, if LA(1) is member of
              the viable next token set, then you know there is most likely
              a missing token in the input stream.  "Insert" one by just not
              throwing an exception.
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.RecoverFromMismatchedToken(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>Attempt to recover from a single missing or extra token.</summary>
            
              EXTRA TOKEN
            
              LA(1) is not what we are looking for.  If LA(2) has the right token,
              however, then assume LA(1) is some extra spurious token.  Delete it
              and LA(2) as if we were doing a normal match(), which advances the
              input.
            
              MISSING TOKEN
            
              If current token is consistent with what could come after
              ttype then it is ok to "insert" the missing token, else throw
              exception For example, Input "i=(3;" is clearly missing the
              ')'.  When the parser returns from the nested call to expr, it
              will have call chain:
            
                stat -> expr -> atom
            
              and it will be trying to match the ')' at this point in the
              derivation:
            
                   => ID '=' '(' INT ')' ('+' atom)* ';'
                                      ^
              match() will see that ';' doesn't match ')' and report a
              mismatched token error.  To recover, it sees that LA(1)==';'
              is in the set of tokens that can follow the ')' token
              reference in rule atom.  It can assume that you forgot the ')'.
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.RecoverFromMismatchedSet(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException,Antlr.Runtime.BitSet)">
            Not currently used 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetCurrentInputSymbol(Antlr.Runtime.IIntStream)">
            <summary>
              Match needs to return the current input symbol, which gets put
              into the label for the associated token ref; e.g., x=ID.  Token
              and tree parsers need to return different objects. Rather than test
              for input stream type or change the IntStream interface, I use
              a simple method to ask the recognizer to tell me what the current
              input symbol is.
              </summary>
            
              <remarks>This is ignored for lexers.</remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetMissingSymbol(Antlr.Runtime.IIntStream,Antlr.Runtime.RecognitionException,System.Int32,Antlr.Runtime.BitSet)">
            <summary>Conjure up a missing token during error recovery.</summary>
            
              <remarks>
              The recognizer attempts to recover from single missing
              symbols. But, actions might refer to that missing symbol.
              For example, x=ID {f($x);}. The action clearly assumes
              that there has been an identifier matched previously and that
              $x points at that token. If that token is missing, but
              the next token in the stream is what we want we assume that
              this token is missing and we keep going. Because we
              have to return some token to replace the missing token,
              we have to conjure one up. This method gives the user control
              over the tokens returned for missing tokens. Mostly,
              you will want to create something special for identifier
              tokens. For literals such as '{' and ',', the default
              action in the parser or tree parser works. It simply creates
              a CommonToken of the appropriate type. The text will be the token.
              If you change what tokens must be created by the lexer,
              override this method to create the appropriate tokens.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.ConsumeUntil(Antlr.Runtime.IIntStream,Antlr.Runtime.BitSet)">
            <summary>Consume tokens until one matches the given token set</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.PushFollow(Antlr.Runtime.BitSet)">
            <summary>Push a rule's follow set using our own hardcoded stack</summary> 
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleInvocationStack(System.Diagnostics.StackTrace)">
            <summary>
            A more general version of GetRuleInvocationStack where you can
            pass in the StackTrace of, for example, a RecognitionException
            to get it's rule stack trace.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleMemoization(System.Int32,System.Int32)">
            <summary>
              Given a rule number and a start token index number, return
              MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
              start index.  If this rule has parsed input starting from the
              start index before, then return where the rule stopped parsing.
              It returns the index of the last token matched by the rule.
              </summary>
            
              <remarks>
              For now we use a hashtable and just the slow Object-based one.
              Later, we can make a special one for ints and also one that
              tosses out data after we commit past input position i.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.AlreadyParsedRule(Antlr.Runtime.IIntStream,System.Int32)">
            <summary>
              Has this rule already parsed input at the current index in the
              input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
              If we attempted but failed to parse properly before, return
              MEMO_RULE_FAILED.
              </summary>
            
              <remarks>
              This method has a side-effect: if we have seen this input for
              this rule and successfully parsed before, then seek ahead to
              1 past the stop token matched for this rule last time.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.Memoize(Antlr.Runtime.IIntStream,System.Int32,System.Int32)">
            <summary>
            Record whether or not this rule parsed the input at this position
            successfully.  Use a standard java hashtable for now.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.BaseRecognizer.GetRuleMemoizationCacheSize">
            <summary>return how many rule/input-index pairs there are in total.</summary>
            TODO: this includes synpreds. :(
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.Failed">
            <summary>Return whether or not a backtracking attempt failed.</summary> 
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.TokenNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.BaseRecognizer.GrammarFileName">
            <summary>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this method.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.ITokenSource.NextToken">
            <summary>
            Return a Token object from your input stream (usually a CharStream).
            Do not fail/return upon lexing error; keep chewing on the characters
            until you get a good one; errors are not passed through to the parser.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.ITokenSource.SourceName">
            <summary>
            Where are you getting tokens from? normally the implication will simply
            ask lexers input stream.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Lexer.input">
            <summary>Where is the lexer drawing characters from?</summary> 
        </member>
        <member name="M:Antlr.Runtime.Lexer.NextToken">
            <summary>Return a token from this source; i.e., match a token on the char stream.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.  nextToken() knows to keep looking when
            a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
            if token==null at end of any token rule, it creates one for you
            and emits it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Emit(Antlr.Runtime.IToken)">
            <summary>
            Currently does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method and
            nextToken (to push tokens into a list and pull from that list rather
            than a single variable as this implementation does).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Emit">
            <summary>
              The standard method called to automatically emit a token at the
              outermost lexical rule.  The token object should point into the
              char buffer start..stop.  If there is a text override in 'text',
              use that to set the token's text.  Override this method to emit
              custom Token objects.
              </summary>
            
              <remarks>
              If you are building trees, then you should also override
              Parser or TreeParser.getMissingSymbol().
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Lexer.Recover(Antlr.Runtime.RecognitionException)">
            <summary>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a fragment rule.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead?</summary> 
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.XsdTableDictionary">
            <summary>
            数据表字典。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.KeywordTokenItem">
            <summary>
            关键字。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.XsdDocument">
            <summary>
            表示数据模型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDocument.Name">
            <summary>
            获取数据模型的名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDocument.TableDictionary">
            <summary>
            获取数据模型中包含的所有数据表的字典。在数据模型的整个树中，不允许存在中文名或英文名相同的表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDocument.Description">
            <summary>
            获取数据模型的描述。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDocument.DataSet">
            <summary>
            获取数据模型的主数据集。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDocument.CnName">
            <summary>
            获取数据模型的中文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDocument.EnName">
            <summary>
            获取数据模型的英文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDocument.AllTables">
            <summary>
            获取数据模型的整个树中包含的所有数据表集合。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDocument.Schema">
            <summary>
            获取或设置 XmlSchema。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSchemaParser.PreprocessXmlSchema(System.String)">
            <summary>
            预处理XmlSchema。
            </summary>
            <param name="xmlSchema">要处理的原始XmlSchema。</param>
            <remarks>
            <para>
            1、此方法执行以下转换：如果要处理的原始XmlSchema中的表或字段不包含中文名，则自动将其英文名转换为中文名。
            </para>
            <para>
            2、使用此方法的风险：试想这样一个场景，有一个字段英文名是[XXCODE]，没有定义中文名，使用此方法预处理后，用户在表达式定义中将使用[XXCODE]引用该字段。
            有一天，原始XmlSchema中给该字段定义了中文名为[某某编号]，再次使用此方法预处理时，则不会再对该字段进行转换。这样造成的后果是，
            当用户对以前定义的表达式进行修改时，如果要通过语法校验，则必须将引用[XXCODE]的地方修改为[某某编号]。
            </para>
            </remarks>
            <returns>处理后的XmlSchema。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSchemaParser.ParseXmlSchema(System.String,System.String,System.String,System.String)">
            <summary>
            将XmlSchema解析成语义化表达式使用的内存表示形式。
            </summary>
            <param name="enName">XmlSchema英文名称。</param>
            <param name="cnName">XmlSchema中文名称。</param>
            <param name="xmlSchema">XmlSchema文档。</param>
            <param name="description">XmlSchema的描述。</param>
            <returns>语义化表达式使用的XmlSchema内存表示形式 <see cref="T:Genersoft.Platform.SemanticExpression.Builder.XsdDocument"/>。</returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.XmlSchemaParser.ExpressionContext">
            <summary>
            获取或设置表达式上下文。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.FunctionIdentifierTokenItem">
            <summary>
            函数标识符。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionIdentifierTokenItem.Function">
            <summary>
            获取与此标识符关联的函数定义。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String)">
            <summary>
            Add a child element with the specific name to the given parent element 
            and return the child element.
            This method will use the namespace of the parent element for the child element's namespace.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.DateTime)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.DateTime,System.DateTime)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            If the given value is null then the default value is used.  
            If the value is null then this method will not add the child element and will return null.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <param name="defaultValue">The default value (if the value is null)</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.Int32)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.Int32,System.Int32)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            If the given value is null then the default value is used.  
            If the value is null then this method will not add the child element and will return null.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <param name="defaultValue">The default value (if the value is null)</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.String,System.String)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            If the given value is null then the default value is used.  
            If the value is null then this method will not add the child element and will return null.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <param name="defaultValue">The default value (if the value is null)</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.Uri)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.Uri,System.Uri)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            If the given value is null then the default value is used.  
            If the value is null then this method will not add the child element and will return null.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <param name="defaultValue">The default value (if the value is null)</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.TimeSpan)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.TimeSpan,System.TimeSpan)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            If the given value is null then the default value is used.  
            If the value is null then this method will not add the child element and will return null.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <param name="defaultValue">The default value (if the value is null)</param>
            <returns>The child element</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.XmlSerializerHelper.AddElement(System.Xml.XmlElement,System.String,System.Enum)">
            <summary>
            Add a child element with the specific name and the given value to the given parent element 
            and return the child element.  
            This method will use the namespace of the parent element for the child element's namespace.
            </summary>
            <param name="parent">The parent element</param>
            <param name="name">The new child element name</param>
            <param name="value">The value</param>
            <returns>The child element</returns>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormSmartHelp.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormSmartHelp.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormSmartHelp.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.DockFormState">
            <summary>
            保存停靠窗体的状态。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.DockFormState.ActiveDockFormIndex">
            <summary>
            获取或设置当前激活显示的窗体的索引。约定：如果没有激活的窗体，此值设为 -1。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.DockFormState.DockFormIsAutoHide">
            <summary>
            获取停靠窗体是否是处于自动隐藏状态。true:处于自动隐藏状态；fale:处于非自动隐藏状态。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.DockFormState.DockFormVisible">
            <summary>
            获取或设置停靠窗体是否可见。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.DockFormState.DockFormWidth">
            <summary>
            获取或设置停靠窗体显示区域的宽度。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.DockFormState.DockFormHeight">
            <summary>
            获取或设置停靠窗体显示区域的高度。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Grammars.Parsing.HintType.ResolveToShift">
            <summary>
            Instruction to resolve conflict to shift
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Grammars.Parsing.HintType.ResolveToReduce">
            <summary>
            Instruction to resolve conflict to reduce
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Grammars.Parsing.HintType.ResolveInCode">
            <summary>
            Instruction to resolve the conflict using special code in grammar in OnResolvingConflict method.
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Grammars.Parsing.HintType.Precedence">
            <summary>
            Currently ignored by Parser, may be used in the future to set specific precedence value of the following terminal operator.
            One example where it can be used is setting higher precedence value for unary + or - operators. This hint would override 
            precedence set for these operators for cases when they are used as unary operators. (YACC has this feature).
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Grammars.Parsing.HintType.Custom">
            <summary>
            Provided for all custom hints that derived solutions may introduce 
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDiagnostic.context">
            <summary>
            表达式上下文。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDiagnostic.syntaxText">
            <summary>
            语义化文本。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDiagnostic.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDiagnostic.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDiagnostic.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormAbout.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormAbout.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormAbout.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormExtendFunctionEditor.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormExtendFunctionEditor.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormExtendFunctionEditor.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Parser">
            <summary>
            A parser for TokenStreams.  "parser grammars" result in a subclass
            of this.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Parser.TokenStream">
            <summary>Gets or sets the token stream; resets the parser upon a set.</summary> 
        </member>
        <member name="T:Antlr.Runtime.ParserRuleReturnScope`1">
            <summary>
              Rules that return more than a single value must return an object
              containing all the values.  Besides the properties defined in
              RuleLabelScope.predefinedRulePropertiesScope there may be user-defined
              return values.  This class simply defines the minimum properties that
              are always defined and methods to access the others that might be
              available depending on output option such as template and tree.
              </summary>
            
              <remarks>
              Note text is not an actual property of the return value, it is computed
              from start and stop using the input stream's toString() method.  I
              could add a ctor to this so that we can pass in and store the input
              stream, but I'm not sure we want to do that.  It would seem to be undefined
              to get the .text property anyway if the rule matches tokens from multiple
              input streams.
            
              I do not use getters for fields of objects that are used simply to
              group values such as this aggregate.  The getters/setters are there to
              satisfy the superclass interface.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.IRuleReturnScope`1">
            <summary>
            Rules can have start/stop info.
            </summary>
            <typeparam name="TLabel">The element type of the input stream.</typeparam>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope`1.Start">
            <summary>
            Gets the start element from the input stream
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IRuleReturnScope`1.Stop">
            <summary>
            Gets the stop element from the input stream
            </summary>
        </member>
        <member name="T:Jint.Native.NativeGenericType">
            <summary>
            This class is used to reflect a native generic.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeRuleReturnScope`1">
            <summary>
            This is identical to the ParserRuleReturnScope except that
            the start property is a tree nodes not Token object
            when you are parsing trees.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.TreeRuleReturnScope`1.Start">
            <summary>Gets the first node or root node of tree matched for this rule.</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteEmptyStreamException">
            <summary>Ref to ID or expr but no tokens in ID stream or subtrees in expr stream</summary> 
        </member>
        <member name="T:Antlr.Runtime.MissingTokenException">
            <summary>
            We were expecting a token but it's not found.  The current token
            is actually what we wanted next.  Used for tree node errors too.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.MismatchedTokenException">
            <summary>A mismatched char or Token or tree node</summary> 
        </member>
        <member name="T:Antlr.Runtime.FailedPredicateException">
            <summary>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we hoist a predicate into
            a prediction decision.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet">
            <summary>
            表示数据模型中的数据集。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.Name">
            <summary>
            获取数据集名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.TableDic">
            <summary>
            获取数据集包含的数据表字典。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.XPath">
            <summary>
            获取元素节点在Xml文档中的XPath（ADP格式）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.AbsoluteXPath">
            <summary>
            获取元素节点在Xml文档中的XPath（绝对路径）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.Document">
            <summary>
            获取数据集隶属的数据模型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.ParentTable">
            <summary>
            获取或设置数据集的父表。如果为 null，则表示数据集是数据模型中的主数据集。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.CnName">
            <summary>
            获取数据集的中文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.EnName">
            <summary>
            获取数据集的英文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdDataSet.Tables">
            <summary>
            获取数据集包含的数据表集合。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.GetConfigFileDirectory">
            <summary>
            获取扩展配置文件的目录。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.GetAllExtendFunctionDic(Genersoft.Platform.SemanticExpression.Common.ExpressionCategory)">
            <summary>
            获取所有扩展配置文件中的函数（不包括 Expression.xml 和 ExpressionConfig.xml 2个文件中的）key：Function.InstanceName。
            </summary>
            <param name="exprCategory">表达式类型。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.BuildExtendConfigFile(Genersoft.Platform.SemanticExpression.SortableBindingList{Genersoft.Platform.SemanticExpression.KeyTermEditorBindingItem},Genersoft.Platform.SemanticExpression.SortableBindingList{Genersoft.Platform.SemanticExpression.KeyTermEditorBindingItem},Genersoft.Platform.SemanticExpression.SortableBindingList{Genersoft.Platform.SemanticExpression.KeyTermEditorBindingItem},Genersoft.Platform.SemanticExpression.SortableBindingList{Genersoft.Platform.SemanticExpression.KeyTermEditorBindingItem},Genersoft.Platform.SemanticExpression.SortableBindingList{Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem},Genersoft.Platform.SemanticExpression.SortableBindingList{Genersoft.Platform.SemanticExpression.SmartHelpEditorBindingItem})">
            <summary>
            根据绑定列表数据构建配置文件。
            </summary>
            <param name="keywordList">关键字列表。</param>
            <param name="operatorList">运算符列表。</param>
            <param name="constantList">常量列表。</param>
            <param name="delimiterList">分隔符列表。</param>
            <param name="funcList">函数列表。</param>
            <param name="smartHelpList">智能帮助列表。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.BuildFunctionEditorBindingList(Genersoft.Platform.SemanticExpression.ExtendConfigFile)">
            <summary>
            获取函数绑定列表。
            </summary>
            <param name="configFile">配置文件。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.BuildKeywordEditorBindingList(Genersoft.Platform.SemanticExpression.ExtendConfigFile)">
            <summary>
            获取关键字绑定列表。
            </summary>
            <param name="configFile">配置文件。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.BuildOperatorEditorBindingList(Genersoft.Platform.SemanticExpression.ExtendConfigFile)">
            <summary>
            获取运算符绑定列表。
            </summary>
            <param name="configFile">配置文件。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.BuildConstantEditorBindingList(Genersoft.Platform.SemanticExpression.ExtendConfigFile)">
            <summary>
            获取常量绑定列表。
            </summary>
            <param name="configFile">配置文件。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.BuildDelimiterEditorBindingList(Genersoft.Platform.SemanticExpression.ExtendConfigFile)">
            <summary>
            获取分隔符绑定列表。
            </summary>
            <param name="configFile">配置文件。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExtendConfigFileHelper.BuildSmartHelpEditorBindingList(Genersoft.Platform.SemanticExpression.ExtendConfigFile)">
            <summary>
            获取智能帮助绑定列表。
            </summary>
            <param name="configFile">配置文件。</param>
            <returns></returns>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDetails.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDetails.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDetails.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormContents.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormContents.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormContents.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Grammars.Interpreter.OperatorDispatchKey">
            <summary>
            The struct is used as a key for the dictionary of operator implementations. 
            Contains types of arguments for a method or operator implementation.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Grammars.Interpreter.OperatorImplementation">
            <summary>
            The OperatorImplementation class represents an implementation of an operator or method with specific argument types.
            </summary>
            <remarks>
             The OperatorImplementation holds 4 method execution components, which are simply delegate references: 
             converters for both arguments, implementation method and converter for the result. 
            </remarks>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Grammars.Interpreter.DynamicCallDispatcher">
            <summary>
            The DynamicCallDispatcher class is responsible for fast dispatching to the implementation based on argument types
            It is one per context which is one per thread.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.ThreeSectionFieldName">
            <summary>
            三段式字段名实体类。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.ThreeSectionFieldName.ToThreeSectionName">
            <summary>
            转换为三段式字段名。
            </summary>
            <returns>三段式字段名。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.ThreeSectionFieldName.FromThreeSectionName(System.String)">
            <summary>
            将三段式字段名转换为实体类。
            </summary>
            <param name="threeSectionName">三段式字段名。</param>
            <returns>三段式字段名实体类。</returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.ThreeSectionFieldName.DataSetName">
            <summary>
            数据集名（即数据模型名）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.ThreeSectionFieldName.TableName">
            <summary>
            表名。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.ThreeSectionFieldName.FieldName">
            <summary>
            字段名。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.BaseControls.Docking.MouseHook">
            <summary>
            侦听鼠标活动
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.MouseHook.#ctor">
            <summary>
            侦听鼠标活动
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.MouseHook.Start">
            <summary>
            开始侦听
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseControls.Docking.MouseHook.Stop">
            <summary>
            停止侦听
            </summary>
        </member>
        <member name="E:Genersoft.Platform.SemanticExpression.BaseControls.Docking.MouseHook.MouseActived">
            <summary>
            当鼠标产生动作后发生
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.DataGridViewHelper">
            <summary>
            DataGridView 助手
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DataGridViewHelper.OpenFormDataGridViewFinder(System.String,System.Windows.Forms.DataGridView)">
            <summary>
            打开数据网格查找窗体
            </summary>
            <param name="caption">附加的标题文本</param>
            <param name="dataGridView">用于查找的数据网格</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.DataGridViewHelper.CloseFormDataGridViewFinder">
            <summary>
            关闭数据网格查找窗体
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeParser">
            <summary>
            A parser for a stream of tree nodes.  "tree grammars" result in a subclass
            of this.  All the error reporting and recovery is shared with Parser via
            the BaseRecognizer superclass.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.SetTreeNodeStream(Antlr.Runtime.Tree.ITreeNodeStream)">
            <summary>Set the input stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.MatchAny(Antlr.Runtime.IIntStream)">
            <summary>
            Match '.' in tree parser has special meaning.  Skip node or
            entire tree if node has children.  If children, scan until
            corresponding UP node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.RecoverFromMismatchedToken(Antlr.Runtime.IIntStream,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            We have DOWN/UP nodes in the stream that have no line info; override.
            plus we want to alter the exception type.  Don't try to recover
            from tree parser errors inline...
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.GetErrorHeader(Antlr.Runtime.RecognitionException)">
            <summary>
            Prefix error message with the grammar name because message is
            always intended for the programmer because the parser built
            the input tree not the user.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeParser.GetErrorMessage(Antlr.Runtime.RecognitionException,System.String[])">
            <summary>
            Tree parsers parse nodes they usually have a token object as
            payload. Set the exception token and do the default behavior.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Debug.IDebugEventListener">
            <summary>All debugging events that a recognizer can trigger.</summary>
            
              <remarks>
              I did not create a separate AST debugging interface as it would create
              lots of extra classes and DebugParser has a dbg var defined, which makes
              it hard to change to ASTDebugEventListener.  I looked hard at this issue
              and it is easier to understand as one monolithic event interface for all
              possible events.  Hopefully, adding ST debugging stuff won't be bad.  Leave
              for future. 4/26/2006.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterRule(System.String,System.String)">
            <summary>
            The parser has just entered a rule.  No decision has been made about
            which alt is predicted.  This is fired AFTER init actions have been
            executed.  Attributes are defined and available etc...
            The grammarFileName allows composite grammars to jump around among
            multiple grammar files.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterAlt(System.Int32)">
            <summary>
            Because rules can have lots of alternatives, it is very useful to
            know which alt you are entering.  This is 1..n for n alts.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ExitRule(System.String,System.String)">
            <summary>
            This is the last thing executed before leaving a rule.  It is
            executed even if an exception is thrown.  This is triggered after
            error reporting and recovery have occurred (unless the exception is
            not caught in this rule).  This implies an "exitAlt" event.
            The grammarFileName allows composite grammars to jump around among
            multiple grammar files.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterSubRule(System.Int32)">
            <summary>Track entry into any (...) subrule other EBNF construct</summary> 
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EnterDecision(System.Int32,System.Boolean)">
            <summary>
            Every decision, fixed k or arbitrary, has an enter/exit event
            so that a GUI can easily track what LT/consume events are
            associated with prediction.  You will see a single enter/exit
            subrule but multiple enter/exit decision events, one for each
            loop iteration.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeToken(Antlr.Runtime.IToken)">
            <summary>
            An input token was consumed; matched by any kind of element.
            Trigger after the token was matched by things like match(), matchAny().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeHiddenToken(Antlr.Runtime.IToken)">
            <summary>
            An off-channel input token was consumed.
            Trigger after the token was matched by things like match(), matchAny().
            (unless of course the hidden token is first stuff in the input stream).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.LT(System.Int32,Antlr.Runtime.IToken)">
            <summary>
            Somebody (anybody) looked ahead.  Note that this actually gets
            triggered by both LA and LT calls.  The debugger will want to know
            which Token object was examined.  Like consumeToken, this indicates
            what token was seen at that depth.  A remote debugger cannot look
            ahead into a file it doesn't have so LT events must pass the token
            even if the info is redundant.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Mark(System.Int32)">
            <summary>
            The parser is going to look arbitrarily ahead; mark this location,
            the token stream's marker is sent in case you need it.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Rewind(System.Int32)">
            <summary>
            After an arbitrairly long lookahead as with a cyclic DFA (or with
            any backtrack), this informs the debugger that stream should be
            rewound to the position associated with marker.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Rewind">
            <summary>
            Rewind to the input position of the last marker.
            Used currently only after a cyclic DFA and just
            before starting a sem/syn predicate to get the
            input position back to the start of the decision.
            Do not "pop" the marker off the state.  mark(i)
            and rewind(i) should balance still.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Location(System.Int32,System.Int32)">
            <summary>
              To watch a parser move through the grammar, the parser needs to
              inform the debugger what line/charPos it is passing in the grammar.
              For now, this does not know how to switch from one grammar to the
              other and back for island grammars etc...
              </summary>
            
              <remarks>
              This should also allow breakpoints because the debugger can stop
              the parser whenever it hits this line/pos.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.BeginResync">
            <summary>
            Indicates the recognizer is about to consume tokens to resynchronize
            the parser.  Any consume events from here until the recovered event
            are not part of the parse--they are dead tokens.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.EndResync">
            <summary>
            Indicates that the recognizer has finished consuming tokens in order
            to resychronize.  There may be multiple beginResync/endResync pairs
            before the recognizer comes out of errorRecovery mode (in which
            multiple errors are suppressed).  This will be useful
            in a gui where you want to probably grey out tokens that are consumed
            but not matched to anything in grammar.  Anything between
            a beginResync/endResync pair was tossed out by the parser.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.SemanticPredicate(System.Boolean,System.String)">
            <summary>A semantic predicate was evaluate with this result and action text</summary> 
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Commence">
            <summary>
            Announce that parsing has begun.  Not technically useful except for
            sending events over a socket.  A GUI for example will launch a thread
            to connect and communicate with a remote parser.  The thread will want
            to notify the GUI when a connection is made.  ANTLR parsers
            trigger this upon entry to the first rule (the ruleLevel is used to
            figure this out).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.Terminate">
            <summary>
            Parsing is over; successfully or not.  Mostly useful for telling
            remote debugging listeners that it's time to quit.  When the rule
            invocation level goes to zero at the end of a rule, we are done
            parsing.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ConsumeNode(System.Object)">
            <summary>
              Input for a tree parser is an AST, but we know nothing for sure
              about a node except its type and text (obtained from the adaptor).
              This is the analog of the consumeToken method.  Again, the ID is
              the hashCode usually of the node so it only works if hashCode is
              not implemented.  If the type is UP or DOWN, then
              the ID is not really meaningful as it's fixed--there is
              just one UP node and one DOWN navigation node.
              </summary>
            
              <param name="t" />
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.LT(System.Int32,System.Object)">
            <summary>
            The tree parser lookedahead.  If the type is UP or DOWN,
            then the ID is not really meaningful as it's fixed--there is
            just one UP node and one DOWN navigation node.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.NilNode(System.Object)">
            <summary>
              A nil was created (even nil nodes have a unique ID...
              they are not "null" per se).  As of 4/28/2006, this
              seems to be uniquely triggered when starting a new subtree
              such as when entering a subrule in automatic mode and when
              building a tree in rewrite mode.
              </summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only t.ID is set.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.ErrorNode(System.Object)">
            <summary>
              Upon syntax error, recognizers bracket the error with an error node
              if they are building ASTs.
              </summary>
            
              <param name="t"/>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.CreateNode(System.Object)">
            <summary>Announce a new node built from token elements such as type etc...</summary>
            
             <remarks>
             If you are receiving this event over a socket via
             RemoteDebugEventSocketListener then only t.ID, type, text are
             set.
             </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.CreateNode(System.Object,Antlr.Runtime.IToken)">
            <summary>Announce a new node built from an existing token.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only node.ID and token.tokenIndex
              are set.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.BecomeRoot(System.Object,System.Object)">
            <summary>Make a node the new root of an existing root.  See</summary>
            
              <remarks>
              Note: the newRootID parameter is possibly different
              than the TreeAdaptor.becomeRoot() newRoot parameter.
              In our case, it will always be the result of calling
              TreeAdaptor.becomeRoot() and not root_n or whatever.
            
              The listener should assume that this event occurs
              only when the current subrule (or rule) subtree is
              being reset to newRootID.
             
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only IDs are set.
              </remarks>
            
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.AddChild(System.Object,System.Object)">
            <summary>Make childID a child of rootID.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only IDs are set.
              </remarks>
            
        </member>
        <member name="M:Antlr.Runtime.Debug.IDebugEventListener.SetTokenBoundaries(System.Object,System.Int32,System.Int32)">
            <summary>Set the token start/stop token index for a subtree root or node.</summary>
            
              <remarks>
              If you are receiving this event over a socket via
              RemoteDebugEventSocketListener then only t.ID is set.
              </remarks>
        </member>
        <member name="P:Antlr.Runtime.IToken.Text">
            <summary>Get the text of the token</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.Line">
            <summary>The line number on which this token was matched; line=1..n</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.CharPositionInLine">
            <summary>The index of the first character relative to the beginning of the line 0..n-1</summary> 
        </member>
        <member name="P:Antlr.Runtime.IToken.TokenIndex">
            <summary>
            An index from 0..n-1 of the token object in the input stream.
            This must be valid in order to use the ANTLRWorks debugger.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.IToken.InputStream">
            <summary>
            From what character stream was this token created?  You don't have to
            implement but it's nice to know where a Token comes from if you have
            include files etc... on the input.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonToken.text">
            <summary>
            We need to be able to change the text once in a while.  If
            this is non-null, then getText should return this.  Note that
            start/stop are not affected by changing this.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonToken.index">
            <summary>What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index</summary> 
        </member>
        <member name="F:Antlr.Runtime.CommonToken.start">
            <summary>The char position into the input buffer where this token starts</summary> 
        </member>
        <member name="F:Antlr.Runtime.CommonToken.stop">
            <summary>The char position into the input buffer where this token stops</summary> 
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SyntaxRichTextBox.ResetExpressionContext(Genersoft.Platform.SemanticExpression.ExpressionContext)">
            <summary>
            重置表达式上下文。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SyntaxRichTextBox.ResetGrammarColorTable(Genersoft.Platform.SemanticExpression.GrammarColorTable)">
            <summary>
            重置语法颜色表。
            </summary>
            <param name="colorTable"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SyntaxRichTextBox.ResetHighLighter">
            <summary>
            重置语法高亮。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor">
            <summary>
            语义化表达式编辑器控件。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.hashtable">
            <summary>
            传入的表达式上下文
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.context">
            <summary>
            解析后的表达式上下文
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isParentFormShown">
            <summary>
            控件所在的窗体是否已经显示
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isDirty">
            <summary>
            表达式文本是否已被修改
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isEditing">
            <summary>
            是否允许编辑
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isShowSaveButton">
            <summary>
            是否显示保存按钮
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isShowSaveAsSubExpressionButton">
            <summary>
            是否显示另存为子表达式按钮
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isShowCloseButton">
            <summary>
            是否显示关闭按钮
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isEnabledFuncWizard">
            <summary>
            是否启用函数向导
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isShowCnKeyword">
            <summary>
            是否显示中文关键字
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isMaximized">
            <summary>
            打开后是否自动最大化窗口
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.contentsControlsDockStyle">
            <summary>
            变量目录停靠位置
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isShowQuickHelp">
            <summary>
            是否显示变量快捷帮助
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isQuickHelpWordWrap">
            <summary>
            变量快捷帮助是否自动换行
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.detailsControl">
            <summary>
            变量明细控件
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.contentsControl">
            <summary>
            变量目录控件
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.formDetails">
            <summary>
            变量明细停靠窗体
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.formContentsLeft">
            <summary>
            变量目录左侧停靠窗体
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.formContentsRight">
            <summary>
            变量目录右侧停靠窗体
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.formOutputDockForm">
            <summary>
            输出停靠窗体
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.formSmartHelp">
            <summary>
            智能帮助停靠窗体
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.grammarColorTable">
            <summary>
            语法颜色表
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.debugContext">
            <summary>
            调试上下文。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isShowSaveWarningOnFormClosing">
            <summary>
            窗体关闭前，如果没有保存表达式时，是否显示保存警告。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.tempExpressionText">
            <summary>
            在初始化上下文前设置的表达式文本。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.referenceManualProcess">
            <summary>
            参考手册进程。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.isShowOldExpressionDesignerButton">
            <summary>
            是否显示旧表达式按钮。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.#ctor">
            <summary>
            以默认方式初始化控件的新实例。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.#ctor(System.Collections.Hashtable)">
            <summary>
            以指定的参数初始化控件的新实例。
            </summary>
            <param name="context">表达式上下文。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.#ctor(System.Collections.Hashtable,System.Boolean)">
            <summary>
            以指定的参数初始化控件的新实例。
            </summary>
            <param name="context">表达式上下文。</param>
            <param name="isDisabledSaveAsSubExpressionButton">根据HR项目组要求，增加了另存为子表达式的功能。true：禁用此功能按钮。false：启用此功能按钮。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.OnLoad(System.EventArgs)">
            <summary>
            重载父类方法，关闭自动选词。
            </summary>
            <param name="e">事件参数。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.ResetExpressionContext(System.Collections.Hashtable)">
            <summary>
            重新设置表达式上下文。调用此方法会按照上下文中的数据重新初始化控件。
            </summary>
            <param name="context">表达式上下文。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.ResetExpressionText(System.String)">
            <summary>
            重新设置表达式文本。
            </summary>
            <param name="expressionText">表达式文本。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.GetExpressionText">
            <summary>
            获取表达式文本。
            </summary>
            <returns>表达式文本。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.AppendLine(System.String)">
            <summary>
            向输出窗口追加一行文本。
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.ResetButtonsEnabled">
            <summary>
            重置按钮 Enabled 和 SyntaxRichTextBox.ReadOnly
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.ResetSemanticOptionsStatus(Genersoft.Platform.SemanticExpression.SemanticOptionsStatus)">
            <summary>
            重置用户选项配置状态。
            </summary>
            <param name="status"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.ResetContentsDockStyle(System.Windows.Forms.DockStyle)">
            <summary>
            重置变量目录停靠位置。
            </summary>
            <param name="newStyle"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.SetLabTip(System.String)">
            <summary>
            设置状态栏提示文本
            </summary>
            <param name="msg"></param>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.FunctionWizardContext">
            <summary>
            为函数向导和智能帮助向导提供上下文数据。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.IsShowSaveButton">
            <summary>
            获取或设置是否显示保存按钮。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.IsShowSaveAsSubExpressionButton">
            <summary>
            获取或设置是否显示另存为子表达式按钮。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.IsShowCloseButton">
            <summary>
            获取或设置是否显示关闭按钮。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.IsEditing">
            <summary>
            获取或设置是否可以对表达式进行修改。true：允许修改。false：只能查看，不能修改。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.IsDirty">
            <summary>
            获取或设置表达式初始加载后是否已被修改。true：已被修改；false：没有修改。
            </summary>
            <remarks>
            当不显示语义化表达式编辑器自身的保存按钮时，在关闭窗体前，应加入对此属性值的判断和保存逻辑。
            如果为 true，请执行保存逻辑后，将此属性值设置为 false，已防止编辑器本身再次弹出提示用户保存的对话框。
            如果是在覆盖窗体的 OnFormClosing 方法中执行判断保存逻辑，请按示例代码所示，将判断保存逻辑的代码放在 base.OnFormClosing(e); 语句之前。
            </remarks>
            <example>
            <code>
            protected override void OnFormClosing(FormClosingEventArgs e)
            {
                if (this.SemanticExprEditor.IsDirty == true)
                {
                    //执行保存逻辑...
                    this.SemanticExprEditor.IsDirty = false;
                }
                 
                base.OnFormClosing(e);
            }
            </code>
            </example>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.IsShowSaveWarningOnFormClosing">
            <summary>
            窗体关闭前，如果没有保存表达式时，是否显示保存警告。默认为 true。
            </summary>
            <remarks>当在一个窗体中承载了多个编辑器控件时（如数据库模式下的编辑器），可以将此属性设置为 false ，关闭单个控件的保存提示，而将提示保存的逻辑统一放在窗体的 FormClosing 事件中进行处理，以避免多次弹出提示保存警告。</remarks>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.XsdFieldWizard">
            <summary>
            获取或设置数据字段输入向导。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.IsShowOldExpressionDesignerButton">
            <summary>
            获取或设置是否显示旧表达式按钮。
            </summary>
        </member>
        <member name="E:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.SaveExpressionRequested">
            <summary>
            当发出保存表达式的请求后发生。
            </summary>
        </member>
        <member name="E:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEditor.SaveAsSubExpressionRequested">
            <summary>
            当发出另存为子表达式的请求后发生。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.ISmartHelpWizard">
            <summary>
            智能帮助向导接口。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.ISmartHelpWizard.ShowWizard(Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext)">
            <summary>
            显示向导。
            </summary>
            <param name="context">语义化表达式设计时上下文。</param>
            <returns>向表达式编辑框中插入的文本。</returns>
        </member>
        <member name="M:Jint.Native.JsNumberConstructor.ToFixedImpl(Jint.Native.JsInstance,Jint.Native.JsInstance[])">
            <summary>
            15.7.4.5
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsNumberConstructor.ToExponentialImpl(Jint.Native.JsInstance,Jint.Native.JsInstance[])">
            <summary>
            15.7.4.6
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsNumberConstructor.ToPrecisionImpl(Jint.Native.JsInstance,Jint.Native.JsInstance[])">
            <summary>
            15.7.4.7
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="P:Jint.Native.JsArray.Class">
            <summary>
            15.4.2
            </summary>
        </member>
        <member name="P:Jint.Native.JsArray.Item(Jint.Native.JsInstance)">
            <summary>
            Overriden indexer to optimize cases when we already have a number
            </summary>
            <param name="key">index</param>
            <returns>value</returns>
        </member>
        <member name="T:Jint.Native.ClrImplDefinition`1">
            <summary>
            Wraps a delegate which can be called as a method on an object, with or without parameters.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.RewriteEarlyExitException">
            <summary>No elements within a (...)+ in a rewrite rule</summary> 
        </member>
        <member name="T:Antlr.Runtime.BitSet">
            <summary>
            A stripped-down version of org.antlr.misc.BitSet that is just
            good enough to handle runtime requirements such as FOLLOW sets
            for automatic error recovery.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.BitSet._bits">
            <summary>The actual data bits</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor">
            <summary>Construct a bitset of size one word (64 bits)</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Construction from a list of integers</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.#ctor(System.Int32)">
            <summary>Construct a bitset given the size</summary>
            <param name="nbits">The size of the bitset in bits</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.Or(Antlr.Runtime.BitSet)">
            <summary>return this | a in a new set</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.Add(System.Int32)">
            <summary>or this element into this set (grow as necessary to accommodate)</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.GrowToInclude(System.Int32)">
            <summary>Grows the set to a larger number of bits.</summary>
            <param name="bit">element that must fit in set</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.SetSize(System.Int32)">
            <summary>Sets the size of a set.</summary>
            <param name="nwords">how many words the new set should be</param>
        </member>
        <member name="M:Antlr.Runtime.BitSet.LengthInLongWords">
            <summary>return how much space is being used by the bits array not how many actually have member bits on.</summary> 
        </member>
        <member name="M:Antlr.Runtime.BitSet.ToArray">
            Is this contained within a? 
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Properties.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Properties.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Properties.Resources.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.XsdFieldBindingItem">
            <summary>
            数据字段标识符绑定项。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.IdentifierBindingItem">
            <summary>
            标识符绑定项。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SortableBindingList`1">
            <summary>
            提供支持排序和查找功能的 BindingList。
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.AsReadOnly">
            <summary>
            返回集合的只读包装
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.Sort(System.String,System.ComponentModel.ListSortDirection)">
            <summary>
            按指定属性名和方向排序
            </summary>
            <param name="propertyName"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.ApplySortCore(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">
            <summary>
            
            </summary>
            <param name="prop"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.RemoveSortCore">
            <summary>
            
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.FindCore(System.ComponentModel.PropertyDescriptor,System.Object)">
            <summary>
            
            </summary>
            <param name="prop"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.SearchComparer(`0)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.FindIndex(System.String,System.Object)">
            <summary>
            搜索与指定属性名和属性值相匹配的第一个元素的从零开始的索引(未找到返回 -1)。
            </summary>
            <param name="propertyName">属性名</param>
            <param name="propertyValue">属性值</param>
            <returns>返回找到的第一个元素从零开始的索引,未找到返回 -1</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.Find(System.String,System.Object)">
            <summary>
            搜索与指定属性名和属性值相匹配的第一个元素(未找到返回 default(T))。
            </summary>
            <param name="propertyName">属性名</param>
            <param name="propertyValue">属性值</param>
            <returns>返回找到的第一个元素,未找到返回 default(T)</returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SortableBindingList`1.SupportsSortingCore">
            <summary>
            
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SortableBindingList`1.IsSortedCore">
            <summary>
            
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SortableBindingList`1.SortDirectionCore">
            <summary>
            
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SortableBindingList`1.SortPropertyCore">
            <summary>
            
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SortableBindingList`1.SupportsSearchingCore">
            <summary>
            
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SortableBindingList`1.PropertyComparer`1.#ctor(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">
            <summary>
            PropertyComparer
            </summary>
            <param name="prop"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.RichTextBoxLineNumber.Update_SizeAndPosition">
            <summary>
            This Sub will run whenever Me.Refresh() is called. It applies the AutoSizing and DockSide settings.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.RichTextBoxLineNumber.Update_VisibleLineNumberItems">
            <summary>
            This Sub determines which textlines are visible in the ParentRichTextBox, and makes LineNumberItems (LineNumber + ItemRectangle)
            for each visible line. They are put into the zLNIs List that will be used by the OnPaint event to draw the LineNumberItems. 
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.RichTextBoxLineNumber.FindStartIndex(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            FindStartIndex is a recursive Sub (one that calls itself) to compute the first visible line that should have a LineNumber.
            </summary>
            <param name="zMin"> this will hold the eventual BestStartIndex when the Sub has completed its run.</param>
            <param name="zMax"></param>
            <param name="zTarget"></param>
            <remarks></remarks>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.RichTextBoxLineNumber.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            OnPaint will go through the enabled elements (vertical ReminderMessage, GridLines, LineNumbers, BorderLines, MarginLines) and will
            draw them if enabled. At the same time, it will build GraphicsPaths for each of those elements (that are enabled), which will be used 
            in SeeThroughMode (if it's active): the figures in the GraphicsPaths will form a customized outline for the control by setting them as the 
            Region of the LineNumber control. Note: the vertical ReminderMessages are only drawn during designtime. 
            </summary>
            <param name="e"></param>
            <remarks></remarks>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InnerResizeBar.BARSIZE_RESIZECONTROL_DOCKNONE">
            <summary>
            待调整控件处于非停靠状态时的宽度或高度
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InnerResizeBar.BARSIZE_RESIZECONTROL_DOCKING">
            <summary>
            待调整控件处于停靠状态时的宽度或高度
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InnerResizeBar.RESIZECONTROL_MINSIZE">
            <summary>
            待调整控件可调整到的最小宽度或高度
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InnerResizeBar.m_StartPoint">
            <summary>
            起点屏幕坐标
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InnerResizeBar.m_EndPoint">
            <summary>
            终点屏幕坐标
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InnerResizeBar.m_ScreenRect">
            <summary>
            以屏幕坐标表示的待调整控件的父控件的工作区矩形
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InnerResizeBar.m_IsResizing">
            <summary>
            是否处于调整大小状态
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.BaseControls.Docking.InnerResizeBar.ResizeControl">
            <summary>
            获取或设置待调整大小的控件(不能是最外层的窗体)
            </summary>
        </member>
        <member name="T:Jint.Native.NativeOverloadImpl`2">
            <summary>
            This class is used in the overload implementation for the NativeConstructor and NativeOverloadImplementation
            </summary>
            <typeparam name="TMemberInfo">A Member info type</typeparam>
            <typeparam name="TImpl">An implementation details type</typeparam>
        </member>
        <member name="T:Jint.Native.JsScope">
            <summary>
            Scope. Uses Prototype inheritance to store scopes hierarchy.
            </summary>
            <remarks>
            Tries to add new properties to the global scope.
            </remarks>
        </member>
        <member name="M:Jint.Native.JsScope.#ctor">
            <summary>
            Creates a new Global scope
            </summary>
        </member>
        <member name="M:Jint.Native.JsScope.#ctor(Jint.Native.JsScope)">
            <summary>
            Creates a new scope inside the specified scope
            </summary>
            <param name="outer">Scope inside which the new scope should be created</param>
        </member>
        <member name="M:Jint.Native.JsScope.GetDescriptor(System.String)">
            <summary>
            Overriden. Returns a property descriptor.
            </summary>
            <remarks>
            Tries to resolve proeprty in the following order:
            
            1. OwnProperty for the current scope
            2. Any property from the bag (if specified).
            3. A property from scopes hierarchy.
            
            A proeprty from the bag will be added as a link to the current scope.
            </remarks>
            <param name="index">Property name.</param>
            <returns>Descriptor</returns>
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.pattern">
            <summary>The tree pattern to lex like "(A B C)"</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.p">
            <summary>Index into input string</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.c">
            <summary>Current char</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.n">
            <summary>How long is the pattern in char?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.TreePatternLexer.sval">
            <summary>Set when token type is ID or ARG (name mimics Java's StreamTokenizer)</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Object)">
            <summary>Create a stream with one element</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.#ctor(Antlr.Runtime.Tree.ITreeAdaptor,System.String,System.Collections.IList)">
            <summary>Create a stream, but feed off an existing list</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.RewriteRuleSubtreeStream.NextNode">
            <summary>
              Treat next element as a single node even if it's a subtree.
              This is used instead of next() when the result has to be a
              tree root node.  Also prevents us from duplicating recently-added
              children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration
              must dup the type node, but ID has been added.
              </summary>
            
              <remarks>
              Referencing a rule result twice is ok; dup entire tree as
              we can't be adding trees as root; e.g., expr expr.
            
              Hideous code duplication here with super.next().  Can't think of
              a proper way to refactor.  This needs to always call dup node
              and super.next() doesn't know which to call: dup node or dup tree.
              </remarks>
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeNodeStream">
            <summary>A stream of tree nodes, accessing nodes from a tree of some kind</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.LT(System.Int32)">
            <summary>
              Get tree node at current input pointer + i ahead where i=1 is next node.
              i&lt;0 indicates nodes in the past.  So LT(-1) is previous node, but
              implementations are not required to provide results for k &lt; -1.
              LT(0) is undefined.  For i&gt;=n, return null.
              Return null for LT(0) and any index that results in an absolute address
              that is negative.
              </summary>
            
              <remarks>
              This is analogus to the LT() method of the TokenStream, but this
              returns a tree node instead of a token.  Makes code gen identical
              for both parser and tree grammars. :)
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.ToString(System.Object,System.Object)">
            <summary>
            Return the text of all nodes from start to stop, inclusive.
            If the stream does not buffer all the nodes then it can still
            walk recursively from start until stop.  You can always return
            null or "" too, but users should not access $ruleLabel.text in
            an action of course in that case.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeNodeStream.ReplaceChildren(System.Object,System.Int32,System.Int32,System.Object)">
            <summary>
              Replace from start to stop child index of parent with t, which might
              be a list.  Number of children may be different
              after this call.  The stream is notified because it is walking the
              tree and might need to know you are monkeying with the underlying
              tree.  Also, it might be able to modify the node stream to avoid
              restreaming for future phases.
              </summary>
            
              <remarks>
              If parent is null, don't do anything; must be at root of overall tree.
              Can't replace whatever points to the parent externally.  Do nothing.
              </remarks>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.Item(System.Int32)">
            <summary>
            Get a tree node at an absolute index i; 0..n-1.
            If you don't want to buffer up nodes, then this method makes no
            sense for you.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TreeSource">
            <summary>
            Where is this stream pulling nodes from?  This is not the name, but
            the object that provides node objects.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TokenStream">
            <summary>
            If the tree associated with this stream was created from a TokenStream,
            you can specify it here.  Used to do rule $text attribute in tree
            parser.  Optional unless you use tree parser rule text attribute
            or output=template and rewrite=true options.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.TreeAdaptor">
            <summary>
            What adaptor can tell me how to interpret/navigate nodes and
            trees.  E.g., get text of a node.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.Tree.ITreeNodeStream.UniqueNavigationNodes">
            <summary>
            As we flatten the tree, we use UP, DOWN nodes to represent
            the tree structure.  When debugging we need unique nodes
            so we have to instantiate new ones.  When doing normal tree
            parsing, it's slow and a waste of memory to create unique
            navigation nodes.  Default should be false;
            </summary>
        </member>
        <member name="T:Antlr.Runtime.LegacyCommonTokenStream">
            <summary>
              The most common stream of tokens is one where every token is buffered up
              and tokens are prefiltered for a certain channel (the parser will only
              see these tokens and cannot change the filter channel number during the
              parse).
              </summary>
            
              <remarks>TODO: how to access the full token stream?  How to track all tokens matched per rule?</remarks>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SetTokenSource(Antlr.Runtime.ITokenSource)">
            <summary>Reset this token stream by setting its token source.</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.FillBuffer">
            <summary>
            Load all tokens from the token source and put in tokens.
            This is done upon first LT request because you might want to
            set some token type / channel overrides before filling buffer.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.Consume">
            <summary>
              Move the input pointer to the next incoming token.  The stream
              must become active with LT(1) available.  consume() simply
              moves the input pointer so that LT(1) points at the next
              input symbol. Consume at least one token.
              </summary>
            
              <remarks>
              Walk past any token not on the channel the parser is listening to.
              </remarks>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SkipOffTokenChannels(System.Int32)">
            <summary>Given a starting index, return the index of the first on-channel token.</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.SetTokenTypeChannel(System.Int32,System.Int32)">
            <summary>
            A simple filter mechanism whereby you can tell this token stream
            to force all tokens of type ttype to be on channel.  For example,
            when interpreting, we cannot exec actions so we need to tell
            the stream to force all WS and NEWLINE to be a different, ignored
            channel.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.GetTokens(System.Int32,System.Int32,Antlr.Runtime.BitSet)">
            <summary>
            Given a start and stop index, return a List of all tokens in
            the token type BitSet.  Return null if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.LT(System.Int32)">
            <summary>
            Get the ith token from the current position 1..n where k=1 is the
            first symbol of lookahead.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.LB(System.Int32)">
            <summary>Look backwards k tokens on-channel tokens</summary> 
        </member>
        <member name="M:Antlr.Runtime.LegacyCommonTokenStream.Get(System.Int32)">
            <summary>
            Return absolute token i; ignore which channel the tokens are on;
            that is, count all tokens not just on-channel tokens.
            </summary>
        </member>
        <member name="P:Antlr.Runtime.LegacyCommonTokenStream.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.ExpressionDataFieldFormat">
            <summary>
            表示数据字段的格式。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.ExpressionDataFieldFormat.NonXmlSchemaName">
            <summary>
            不包含 XmlSchema 名称。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.ExpressionDataFieldFormat.WithXmlSchemaName">
            <summary>
            包含 XmlSchema 名称。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Interpreter.LanguageRuntime.GetBaseTypeForExpression(System.String,System.Type,System.Type)">
            <summary>
            Returns the type to which arguments should be converted to perform the operation
            for a given operator and arguments type.
            </summary>
            <param name="op">Operator</param>
            <param name="type1">The type of the first argument.</param>
            <param name="type2">The type of the second argument</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Grammars.Interpreter.LanguageRuntime.GetUpType(System.Type)">
            <summary>
            Returns the "up-type" to use in operation instead of the type that caused overflow.
            </summary>
            <param name="type">The base type for operation that caused overflow.</param>
            <returns>The type to use for operation.</returns>
            <remarks>
            Can be overwritten in language implementation to implement different type-conversion policy.
            </remarks>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BindingItemHelper.GetAllVariableBindingDataSource(Genersoft.Platform.SemanticExpression.IdentifierTokenItemDictionary)">
            <summary>
            获取所有变量的绑定集合（系统变量、上下文变量、子表达式）。
            </summary>
            <param name="tokenTermDic"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BindingItemHelper.GetAllFunctionBindingDataSource(Genersoft.Platform.SemanticExpression.IdentifierTokenItemDictionary)">
            <summary>
            获取所有函数的绑定集合。
            </summary>
            <param name="tokenTermDic"></param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BindingItemHelper.CreateCnNameColumn">
            <summary>
            语义化名称列。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BindingItemHelper.CreateEnNameColumn">
            <summary>
            编号列。
            </summary>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BindingItemHelper.CreateFillColumn">
            <summary>
            最后自动填充列。
            </summary>
            <returns></returns>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.GrammarColorTable">
            <summary>
            语法颜色表。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.SemanticSpecificEvaluator">
            <summary>
            针对特定情况的解析器。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticSpecificEvaluator.HR_EvaluateExpressions(System.String,System.String,Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator,System.Collections.Generic.List{Genersoft.Platform.SemanticExpression.Evaluation.HRObjectRelation})">
            <summary>
            按照列进行内存计算。此方法实现HR的特定解析需求。
            </summary>
            <param name="threeSectionFieldName">要计算字段的三段式字段名。</param>
            <param name="expression">语义化表达式。</param>
            <param name="eva">语义化表达式解析器实例。</param>
            <param name="relations">主从表关系列表。</param>
            <returns>要计算字段所在的数据集。</returns>
        </member>
        <member name="T:Jint.Native.LinkedDescriptor">
            <summary>
            Linked descriptor - a link to the particular property (represented by a descriptor) of the particular object.
            </summary>
            <remarks>
            This descriptors are used in scopes
            </remarks>
        </member>
        <member name="M:Jint.Native.LinkedDescriptor.#ctor(Jint.Native.JsDictionaryObject,System.String,Jint.Native.Descriptor,Jint.Native.JsDictionaryObject)">
            <summary>
            Constructs new descriptor
            </summary>
            <param name="owner">An owner of the new descriptor</param>
            <param name="name">A name of the new descriptor</param>
            <param name="source">A property descriptor of the target object to which we should link to</param>
            <param name="that">A target object to whose property we are linking. This parameter will be
            used in the calls to a 'Get' and 'Set' properties of the source descriptor.</param>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.DisplayIndexToColumnIndex(System.Int32)">
            <summary>
            根据列的显示顺序查找列的实际索引。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.FindText(System.Windows.Forms.DataGridViewCell,System.String)">
            <summary>
            在指定单元格中查找是否包含指定文本。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.FindNextMatchCellInRow(System.Windows.Forms.DataGridViewRow,System.Int32,System.String)">
            <summary>
            在行中查找下一个匹配并可见的单元格。如果找不到返回空值。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.FindMatchNextCell(System.Windows.Forms.DataGridView,System.Windows.Forms.DataGridViewCell,System.String)">
            <summary>
            查找当前单元格的下一个匹配并可见的单元格。如果循环搜索回当前单元格还没有搜到匹配单元格则返回空值。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.TopLevelFrom">
            <summary>
            获取顶层窗体
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FormDataGridViewFinder.DataGridView">
            <summary>
            获取或设置用于查找的数据网格(设为null则禁用所有功能)
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.ContextVariableIdentifierTokenItem">
            <summary>
            上下文变量标识符。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.ExpressionTextEntity">
            <summary>
            表示用户最终存储的表达式文本的实体类。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionTextEntity.ExpressionText">
            <summary>
            用户最终存储的表达式的原始文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionTextEntity.Version">
            <summary>
            表达式的版本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionTextEntity.ExpressionEntity">
            <summary>
            语义化表达式实体类。如果原始文本不是语义化表达式，则此返回 null。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.EvaluatorDataSetDictionary">
            <summary>
            解析器使用的数据集字典。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.EvaluatorDataSetDictionary.Add(System.String,System.Data.DataSet)">
            <summary>
            将指定的键和值添加到字典中。
            </summary>
            <param name="key">键。</param>
            <param name="value">值。</param>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext">
            <summary>
            语义化表达式设计时上下文。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext.ReceivedExpressionCategory">
            <summary>
            获取传入的表达式类型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext.ReceivedXmlSchemaEntryList">
             <summary>
            获取传入的 XmlSchema 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext.ReceivedExpressionConfigEntryList">
             <summary>
            获取传入的 ExpressionConfig 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext.ReceivedSessionVariableEntryList">
             <summary>
            获取传入的 SessionVariable 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext.ReceivedContextVariableEntryList">
             <summary>
            获取传入的 ContextVariable 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext.ReceivedSubExpressionEntryList">
             <summary>
            获取传入的 SubExpression 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext.ParsedXsdDocumentList">
            <summary>
            获取传入的 XmlSchema 项，经过解析后的数据模型列表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilderContext.CurrentSmartHelpTag">
            <summary>
            获取用户当前点击的智能帮助项的自定义标记信息。
            </summary>
        </member>
        <member name="M:Jint.Native.JsGlobal.Eval(Jint.Native.JsInstance[])">
            <summary>
            15.1.2.1
            </summary>
        </member>
        <member name="M:Jint.Native.JsGlobal.ParseInt(Jint.Native.JsInstance[])">
            <summary>
            15.1.2.2
            </summary>
        </member>
        <member name="M:Jint.Native.JsGlobal.ParseFloat(Jint.Native.JsInstance[])">
            <summary>
            15.1.2.3
            </summary>
        </member>
        <member name="M:Jint.Native.JsGlobal.IsNaN(Jint.Native.JsInstance[])">
            <summary>
            15.1.2.4
            </summary>
        </member>
        <member name="M:Jint.Native.JsGlobal.isFinite(Jint.Native.JsInstance[])">
            <summary>
            15.1.2.5
            </summary>
        </member>
        <member name="P:Jint.Native.JsGlobal.Visitor">
            <summary>
            Useful for eval()
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseHelper.IsNullOrWhiteSpace(System.String)">
            <summary>
            判断指定的字符串是 null、空还是仅有空白字符组成。
            </summary>
            <param name="str">要判断的字符串。</param>
            <returns></returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseHelper.Clone``1(``0)">
            <summary>
            Clone the passed object providing an exact replica.Object must be serializable.
            </summary>
            <param name="objectToClone">The object to clone</param>
            <returns>A clone of the original object</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseHelper.ConvertObject(System.Object)">
            <summary>
            转换对象类型。此函数对特殊情况的数据类型进行转换。
            </summary>
            <param name="obj">要转换的对象</param>
            <returns>转换后的对象</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.BaseHelper.MathRound(System.Decimal,System.Int32)">
            <summary>
            数学意义上的四舍五入。
            </summary>
            <param name="d">要进行四舍五入的数值。</param>
            <param name="decimals">保留的小数位数。</param>
            <returns>四舍五入后对的数值。</returns>
        </member>
        <member name="T:Antlr.Runtime.UnwantedTokenException">
            <summary>An extra token while parsing a TokenStream</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.TreeVisitor">
            <summary>Do a depth first walk of a tree, applying pre() and post() actions as we go.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeVisitor.Visit(System.Object,Antlr.Runtime.Tree.ITreeVisitorAction)">
            <summary>
            Visit every node in tree t and trigger an action for each node
            before/after having visited all of its children.  Bottom up walk.
            Execute both actions even if t has no children.  Ignore return
            results from transforming children since they will have altered
            the child list of this node (their parent).  Return result of
            applying post action to this node.
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.DebugVariableBindingItem">
            <summary>
            调试数据源变量绑定项。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.DebugContext">
            <summary>
            调试上下文。
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.ITreeVisitorAction">
            <summary>
            How to execute code for node t when a visitor visits node t.  Execute
            pre() before visiting children and execute post() after visiting children.
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeVisitorAction.Pre(System.Object)">
            <summary>
            Execute an action before visiting children of t.  Return t or
            a rewritten t.  It is up to the visitor to decide what to do
            with the return value.  Children of returned value will be
            visited if using TreeVisitor.visit().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.ITreeVisitorAction.Post(System.Object)">
            <summary>
            Execute an action after visiting children of t.  Return t or
            a rewritten t.  It is up to the visitor to decide what to do
            with the return value.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.Tree.CommonErrorNode">
            <summary>A node representing erroneous token range in token stream</summary> 
        </member>
        <member name="T:Antlr.Runtime.Tree.BufferedTreeNodeStream">
            <summary>A buffered stream of tree nodes.  Nodes can be from a tree of ANY kind.</summary>
            
              This node stream sucks all nodes out of the tree specified in
              the constructor during construction and makes pointers into
              the tree using an array of Object pointers. The stream necessarily
              includes pointers to DOWN and UP and EOF nodes.
            
              This stream knows how to mark/release for backtracking.
            
              This stream is most suitable for tree interpreters that need to
              jump around a lot or for tree parsers requiring speed (at cost of memory).
              There is some duplicated functionality here with UnBufferedTreeNodeStream
              but just in bookkeeping, not tree walking etc...
            
              TARGET DEVELOPERS:
            
              This is the old CommonTreeNodeStream that buffered up entire node stream.
              No need to implement really as new CommonTreeNodeStream is much better
              and covers what we need.
            
              @see CommonTreeNodeStream
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.nodes">
            <summary>The complete mapping from stream index to tree node.
              This buffer includes pointers to DOWN, UP, and EOF nodes.
              It is built upon ctor invocation.  The elements are type
              Object as we don't what the trees look like.</summary>
            
              Load upon first need of the buffer so we can set token types
              of interest for reverseIndexing.  Slows us down a wee bit to
              do all of the if p==-1 testing everywhere though.
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.root">
            <summary>Pull nodes from which tree?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.tokens">
            <summary>IF this tree (root) was created from a token stream, track it.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.adaptor">
            <summary>What tree adaptor was used to build these trees</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.uniqueNavigationNodes">
            <summary>Reuse same DOWN, UP navigation nodes unless this is true</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.p">
            <summary>The index into the nodes list of the current node (next node
            to consume).  If -1, nodes array not filled yet.</summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.lastMarker">
            <summary>Track the last mark() call result value for use in rewind().</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.BufferedTreeNodeStream.calls">
            <summary>Stack of indexes used for push/pop calls</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.FillBuffer">
            Walk tree with depth-first-search and fill nodes buffer.
            Don't do DOWN, UP nodes if its a list (t is isNil).
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.GetNodeIndex(System.Object)">
            What is the stream index for node? 0..n-1
            Return -1 if node not found.
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.AddNavigationNode(System.Int32)">
            As we flatten the tree, we use UP, DOWN nodes to represent
            the tree structure.  When debugging we need unique nodes
            so instantiate new ones when uniqueNavigationNodes is true.
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.LB(System.Int32)">
            <summary>Look backwards k nodes</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.Push(System.Int32)">
            <summary>
            Make stream jump to a new location, saving old location.
            Switch back with pop().
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.Pop">
            <summary>
            Seek back to previous index saved during last push() call.
            Return top of stack (return index).
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.ToTokenTypeString">
            <summary>Used for testing, just return the token type stream</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.BufferedTreeNodeStream.ToTokenString(System.Int32,System.Int32)">
            <summary>Debugging</summary> 
        </member>
        <member name="T:Antlr.Runtime.TokenRewriteStream">
            Useful for dumping out the input stream after doing some
              augmentation or other manipulations.
            
              You can insert stuff, replace, and delete chunks.  Note that the
              operations are done lazily--only if you convert the buffer to a
              String.  This is very efficient because you are not moving data around
              all the time.  As the buffer of tokens is converted to strings, the
              toString() method(s) check to see if there is an operation at the
              current index.  If so, the operation is done and then normal String
              rendering continues on the buffer.  This is like having multiple Turing
              machine instruction streams (programs) operating on a single input tape. :)
            
              Since the operations are done lazily at toString-time, operations do not
              screw up the token index values.  That is, an insert operation at token
              index i does not change the index values for tokens i+1..n-1.
            
              Because operations never actually alter the buffer, you may always get
              the original token stream back without undoing anything.  Since
              the instructions are queued up, you can easily simulate transactions and
              roll back any changes if there is an error just by removing instructions.
              For example,
            
               CharStream input = new ANTLRFileStream("input");
               TLexer lex = new TLexer(input);
               TokenRewriteStream tokens = new TokenRewriteStream(lex);
               T parser = new T(tokens);
               parser.startRule();
            
             	 Then in the rules, you can execute
                  Token t,u;
                  ...
                  input.insertAfter(t, "text to put after t");}
             		input.insertAfter(u, "text after u");}
             		System.out.println(tokens.toString());
            
              Actually, you have to cast the 'input' to a TokenRewriteStream. :(
            
              You can also have multiple "instruction streams" and get multiple
              rewrites from a single pass over the input.  Just name the instruction
              streams and use that name again when printing the buffer.  This could be
              useful for generating a C file and also its header file--all from the
              same buffer:
            
                  tokens.insertAfter("pass1", t, "text to put after t");}
             		tokens.insertAfter("pass2", u, "text after u");}
             		System.out.println(tokens.toString("pass1"));
             		System.out.println(tokens.toString("pass2"));
            
              If you don't use named rewrite streams, a "default" stream is used as
              the first example shows.
        </member>
        <member name="T:Antlr.Runtime.CommonTokenStream">
            <summary>
              The most common stream of tokens is one where every token is buffered up
              and tokens are prefiltered for a certain channel (the parser will only
              see these tokens and cannot change the filter channel number during the
              parse).
              </summary>
            
              <remarks>TODO: how to access the full token stream?  How to track all tokens matched per rule?</remarks>
        </member>
        <member name="F:Antlr.Runtime.BufferedTokenStream._tokens">
            Record every single token pulled from the source so we can reproduce
            chunks of it later.  The buffer in LookaheadStream overlaps sometimes
            as its moving window moves through the input.  This list captures
            everything so we can access complete input text.
        </member>
        <member name="F:Antlr.Runtime.BufferedTokenStream._lastMarker">
            Track the last mark() call result value for use in rewind(). 
        </member>
        <member name="F:Antlr.Runtime.BufferedTokenStream._p">
            The index into the tokens list of the current token (next token
            to consume).  tokens[p] should be LT(1).  p=-1 indicates need
            to initialize with first token.  The ctor doesn't get a token.
            First call to LT(1) or whatever gets the first token and sets p=0;
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Consume">
            Move the input pointer to the next incoming token.  The stream
              must become active with LT(1) available.  consume() simply
              moves the input pointer so that LT(1) points at the next
              input symbol. Consume at least one token.
            
              Walk past any token not on the channel the parser is listening to.
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Sync(System.Int32)">
            Make sure index i in tokens has a token. 
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.Fetch(System.Int32)">
            add n elements to buffer 
        </member>
        <member name="M:Antlr.Runtime.BufferedTokenStream.GetTokens(System.Int32,System.Int32,Antlr.Runtime.BitSet)">
            Given a start and stop index, return a List of all tokens in
            the token type BitSet.  Return null if no tokens were found.  This
            method looks at both on and off channel tokens.
        </member>
        <member name="P:Antlr.Runtime.BufferedTokenStream.Range">
            <summary>
            How deep have we gone?
            </summary>
        </member>
        <member name="F:Antlr.Runtime.CommonTokenStream._channel">
            Skip tokens on any channel but this one; this is how we skip whitespace... 
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.Consume">
            Always leave p on an on-channel token. 
        </member>
        <member name="M:Antlr.Runtime.CommonTokenStream.SkipOffTokenChannels(System.Int32)">
            Given a starting index, return the index of the first on-channel
            token.
        </member>
        <member name="P:Antlr.Runtime.CommonTokenStream.TokenSource">
            Reset this token stream by setting its token source. 
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.programs">
            <summary>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps String (name) -> rewrite (List)
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.lastRewriteTokenIndexes">
            <summary>Map String (program name) -> Integer index</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.Rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.  UNTESTED!
            </summary>
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.DeleteProgram(System.String)">
            <summary>Reset the program so that no instructions exist</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.ReduceToSingleOperationPerIndex(System.Collections.Generic.IList{Antlr.Runtime.TokenRewriteStream.RewriteOperation})">
            We need to combine operations and report invalid operations (like
              overlapping replaces that are not completed nested).  Inserts to
              same index need to be combined etc...   Here are the cases:
            
              I.i.u I.j.v								leave alone, nonoverlapping
              I.i.u I.i.v								combine: Iivu
            
              R.i-j.u R.x-y.v	| i-j in x-y			delete first R
              R.i-j.u R.i-j.v							delete first R
              R.i-j.u R.x-y.v	| x-y in i-j			ERROR
              R.i-j.u R.x-y.v	| boundaries overlap	ERROR
            
              Delete special case of replace (text==null):
              D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
            
              I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
            											we're not deleting i)
              I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
              R.x-y.v I.i.u | i in x-y				ERROR
              R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
              R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
            
              I.i.u = insert u before op @ index i
              R.x-y.u = replace x-y indexed tokens with u
            
              First we need to examine replaces.  For any replace op:
            
             		1. wipe out any insertions before op within that range.
            		2. Drop any replace op before that is contained completely within
                     that range.
            		3. Throw exception upon boundary overlap with any previous replace.
            
              Then we can deal with inserts:
            
             		1. for any inserts to same index, combine even if not adjacent.
             		2. for any prior replace with same left boundary, combine this
                     insert with replace and delete this replace.
             		3. throw exception if index in same range as previous replace
            
              Don't actually delete; make op null in list. Easier to walk list.
              Later we can throw as we add to index -> op map.
            
              Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
              inserted stuff would be before the replace range.  But, if you
              add tokens in front of a method body '{' and then delete the method
              body, I think the stuff before the '{' you added should disappear too.
            
              Return a map from token index to operation.
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.GetKindOfOps(System.Collections.Generic.IList{Antlr.Runtime.TokenRewriteStream.RewriteOperation},System.Type,System.Int32)">
            <summary>Get all operations before an index of a particular kind</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.RewriteOperation.instructionIndex">
            <summary>What index into rewrites List are we?</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenRewriteStream.RewriteOperation.index">
            <summary>Token buffer index.</summary> 
        </member>
        <member name="M:Antlr.Runtime.TokenRewriteStream.RewriteOperation.Execute(System.Text.StringBuilder)">
            <summary>
            Execute the rewrite operation by possibly adding to the buffer.
            Return the index of the next token to operate on.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.TokenRewriteStream.ReplaceOp">
            <summary>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </summary>
        </member>
        <member name="T:Antlr.Runtime.ANTLRReaderStream">
            <summary>
              Vacuum all input from a Reader and then treat it like a StringStream.
              Manage the buffer manually to avoid unnecessary data copying.
              </summary>
            
              <remarks>
              If you need encoding, use ANTLRInputStream.
              </remarks>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.TokenItemType.Unknow">
            <summary>
            未知
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.TokenItemType.Keyword">
            <summary>
            关键字
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.TokenItemType.Identifier">
            <summary>
            标识符
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.TokenItemType.Constant">
            <summary>
            常量
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.TokenItemType.Operator">
            <summary>
            运算符
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.TokenItemType.Delimiter">
            <summary>
            分隔符
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.TokenItemType.FieldNameTag">
            <summary>
            字段名标记
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SemanticException">
            <summary>
            语义化表达式异常。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SemanticException.#ctor">
            <summary> 构造函数 </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SemanticException.#ctor(System.String)">
            <summary> 构造函数 </summary>
            <param name="message">异常提示信息</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.SemanticException.#ctor(System.String,System.Exception)">
            <summary> 构造函数 </summary>
            <param name="message">异常提示信息</param>
            <param name="innerException">引发该异常的异常</param>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType">
            <summary>
            接收到的上下文项的类型。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.Unknow">
            <summary>
            未知
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.XmlSchema">
            <summary>
            XmlSchema
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.ExpressionConfig">
            <summary>
            扩展配置文件
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.SessionVariable">
            <summary>
            Session 变量
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.ContextVariable">
            <summary>
            上下文变量
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.SubExpression">
            <summary>
            子表达式
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.ExpressionText">
            <summary>
            表达式文本
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.ExpressionType">
            <summary>
            表达式类型(MemoryMode|SQLServer|Oracle)
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Builder.ReceivedEntryType.ExpressionDataFieldFormat">
            <summary>
            数据字段方式
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormGrammarColorTable.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormGrammarColorTable.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormGrammarColorTable.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FormGrammarColorTable.GrammarColorTableXml">
            <summary>
            获取语法颜色表Xml。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.FormDataBaseExprEditor.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDataBaseExprEditor.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.FormDataBaseExprEditor.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.TokenTypes.Down">
            <summary>imaginary tree navigation type; traverse "get child" link</summary> 
        </member>
        <member name="F:Antlr.Runtime.TokenTypes.Up">
            <summary>imaginary tree navigation type; finish with a child list</summary> 
        </member>
        <member name="T:Antlr.Runtime.ClassicToken">
            <summary>
            A Token object like we'd use in ANTLR 2.x; has an actual string created
            and associated with this object.  These objects are needed for imaginary
            tree nodes that have payload objects.  We need to create a Token object
            that has a string; the tree node will point at this token.  CommonToken
            has indexes into a char stream and hence cannot be used to introduce
            new strings.
            </summary>
        </member>
        <member name="F:Antlr.Runtime.ClassicToken.index">
            <summary>What token number is this from 0..n-1 tokens</summary> 
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.XsdTable">
            <summary>
            表示数据模型中的数据表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.Name">
            <summary>
            获取数据表名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.FieldDic">
            <summary>
            获取数据表包含的数据字段字典。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.XPath">
            <summary>
            获取元素节点在Xml文档中的XPath（ADP格式）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.AbsoluteXPath">
            <summary>
            获取元素节点在Xml文档中的XPath（绝对路径）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.ParentDataSet">
            <summary>
            获取数据表隶属的数据集。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.ChildDataSetList">
            <summary>
            获取数据表包含的子数据集列表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.CnName">
            <summary>
            获取数据表的中文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.EnName">
            <summary>
            获取数据表的英文名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.XsdTable.Fields">
            <summary>
            获取数据表包含的字段集合。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.ContentsControl.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContentsControl.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ContentsControl.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Common.ExpressionVersion">
            <summary>
            表示表达式的版本。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Common.ExpressionVersion.Empty">
            <summary>
            空文本。null | 空串 | Trim()后为空串
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Common.ExpressionVersion.Old">
            <summary>
            老表达式版本。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Common.ExpressionVersion.Semantic">
            <summary>
            语义化版本。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus">
            <summary>
            保存用户选项状态。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.LeftDockFormState">
            <summary>
            左边停靠窗体状态。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.RightDockFormState">
            <summary>
            右边停靠窗体状态。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.BottomDockFormState">
            <summary>
            底部停靠窗体状态。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.ContentsDockStyle">
            <summary>
            变量目录控件的停靠位置。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.IsSyntaxEditorWordWrap">
            <summary>
            表达式编辑控件是否自动换行。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.IsQuickHelpWordWrap">
            <summary>
            变量快捷帮助控件是否自动换行。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.IsShowQuickHelp">
            <summary>
            是否显示变量快捷帮助控件。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.ContentsWidth">
            <summary>
            变量窗口中目录控件的宽度。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.QuickHelpWidth">
            <summary>
            变量窗口中快捷帮助控件的宽度。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.IsEnabledFuncWizard">
            <summary>
            是否启用函数向导
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.IsShowCnKeyword">
            <summary>
            是否显示中文关键字
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.IsMaximized">
            <summary>
            打开后是否自动最大化窗口
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.FontName">
            <summary>
            编辑器字体。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.FontSize">
            <summary>
            编辑器字体大小。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.SemanticOptionsStatus.GrammarColorTable">
            <summary>
            语法颜色表
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventHandler">
            <summary>
            表示处理请求保存表达式事件的方法。
            </summary>
            <param name="sender">事件源。</param>
            <param name="e">事件参数。</param>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder">
            <summary>
            语义化表达式构造类。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.GetContext">
            <summary>
            获取表达式上下文。
            </summary>
            <returns>表达式上下文。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.BuildExpression">
            <summary>
            以模式对话框的方式打开语义化表达式编辑器。
            </summary>
            <returns>表达式文本。</returns>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddXmlSchema(System.String,System.String,System.String)">
            <summary>
            添加 XmlSchema。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="xmlSchemaDocument">XmlSchema 文档。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddXmlSchema(System.String,System.String,System.String,System.String)">
            <summary>
            添加 XmlSchema。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="xmlSchemaDocument">XmlSchema 文档。</param>
            <param name="description">描述。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddExpressionConfig(System.String)">
            <summary>
            添加扩展配置文件。
            </summary>
            <param name="configFileName">要添加的配置文件名。注：不包含 xml 文件的后缀名。例如：要添加的配置文件为 HR.xml，则传入 HR 。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddExpressionConfigByFolder(System.String)">
            <summary>
            添加指定文件夹下所有的扩展配置文件。
            </summary>
            <param name="folderName">文件夹名。此文件夹应为 ExpressionConfig 目录的直接子目录。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddSessionVariable(System.String,System.String)">
            <summary>
            添加系统 session 变量。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddSessionVariable(System.String,System.String,System.String)">
            <summary>
            添加系统 session 变量。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="value">变量的值。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddSessionVariable(System.String,System.String,System.String,System.String)">
            <summary>
            添加系统 session 变量。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="value">变量的值。</param>
            <param name="description">描述。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddContextVariable(System.String,System.String)">
            <summary>
            添加上下文变量。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddContextVariable(System.String,System.String,System.String)">
            <summary>
            添加上下文变量。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="value">变量的值。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddContextVariable(System.String,System.String,System.String,System.String)">
            <summary>
            添加上下文变量。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="value">变量的值。</param>
            <param name="description">描述。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddSubExpression(System.String,System.String,System.String)">
            <summary>
            添加子表达式。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="expressionText">表达式文本。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.AddSubExpression(System.String,System.String,System.String,System.String)">
            <summary>
            添加子表达式。
            </summary>
            <param name="enName">英文名称。</param>
            <param name="cnName">中文名称。</param>
            <param name="expressionText">表达式文本。</param>
            <param name="description">描述。</param>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.ExpressionText">
            <summary>
            获取或设置表达式文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.ExpressionCategory">
            <summary>
            获取或设置表达式类型。如果不设置，默认为 ExpressionType.MemoryMode。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.IsEnabledSaveAsSubExpressionButton">
            <summary>
            获取或设置一个值，该值指示是否启用另存为子表达式按钮。默认为 false，不启用。如果启用，请订阅 SaveAsSubExpressionRequested 事件，添加保存逻辑。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.IsEnabledOldExpressionDesigner">
             <summary>
             获取或设置一个值，该值指示是否启用旧表达式编辑器。默认为 false，不启用。
             </summary>
             <remarks>
             <para>
             启用时：如果要编辑的表达式是旧表达式格式，则直接打开旧表达式编辑器进行编辑。
             如果要编辑的表达式为空或语义化表达式格式时，则打开语义化表达式编辑器进行编辑，界面上显示“旧表达式”按钮。
             </para>
             <para>
             不启用时：任何的表达式格式都使用语义化表达式编辑器进行编辑，且界面上不显示“旧表达式”按钮。
             </para>
            </remarks>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.XsdFieldWizard">
            <summary>
            获取或设置数据字段输入向导。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.IsEditing">
            <summary>
            获取或设置是否允许用户编辑。
            </summary>
        </member>
        <member name="E:Genersoft.Platform.SemanticExpression.Builder.SemanticExprBuilder.SaveAsSubExpressionRequested">
            <summary>
            当发出另存为子表达式的请求后发生。
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Math.MathResources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitByte">
            <summary>
              查找类似 big integer won&apos;t fit into byte 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitChar">
            <summary>
              查找类似 big integer won&apos;t fit into char 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitDecimal">
            <summary>
              查找类似 big integer won&apos;t fit into decimal 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitInt">
            <summary>
              查找类似 big integer won&apos;t fit into int 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitLong">
            <summary>
              查找类似 big integer won&apos;t fit into long 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitSByte">
            <summary>
              查找类似 big integer won&apos;t fit into sbyte 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitShort">
            <summary>
              查找类似 big integer won&apos;t fit into short 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitUInt">
            <summary>
              查找类似 big integer won&apos;t fit into uint 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitULong">
            <summary>
              查找类似 big integer won&apos;t fit into ulong 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.BigIntWontFitUShort">
            <summary>
              查找类似 big integer won&apos;t fit into ushort 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.ComplexDivizionByZero">
            <summary>
              查找类似 complex division by zero 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.ExpectedInteger">
            <summary>
              查找类似 expected integer 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.FormatNotImplemented">
            <summary>
              查找类似 format not implemented 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.InvalidArgument">
            <summary>
              查找类似 invalid argument 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.NonNegativePower">
            <summary>
              查找类似 power must be &gt;= 0 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.RadixGreaterThan36">
            <summary>
              查找类似 radix must be &lt;= 36 的本地化字符串。
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Math.MathResources.RadixLessThan2">
            <summary>
              查找类似 radix must be &gt;= 2 的本地化字符串。
            </summary>
        </member>
        <member name="M:Jint.Native.NativeTypeConstructor.CreateNativeTypeConstructor(Jint.Native.IGlobal)">
            <summary>
            A static fuction for creating a constructor for <c>System.Type</c>
            </summary>
            <remarks>It also creates and initializes [[prototype]] and 'prototype' property to
            the same function object.</remarks>
            <param name="global">Global object</param>
            <returns>A js constructor function</returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.ToStringImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.2
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.ToLocaleStringImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.ToDateStringImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.3
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.ToTimeStringImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.4
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.ToLocaleDateStringImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.6
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.ToLocaleTimeStringImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.7
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.ValueOfImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.8
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetTimeImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.9
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetFullYearImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.10
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetUTCFullYearImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.11
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetMonthImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.12
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetUTCMonthImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.13
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetDateImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.14
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetUTCDateImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.15
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetDayImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.16
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetUTCDayImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.17
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetHoursImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.18
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetUTCHoursImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.19
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetMinutesImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.20
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetUTCMinutesImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.21
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.ToUTCStringImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetSecondsImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.22
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetUTCSecondsImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.23
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetMillisecondsImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.24
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetUTCMillisecondsImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.25
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.GetTimezoneOffsetImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.26
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetTimeImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.27
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetMillisecondsImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.28
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetUTCMillisecondsImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.29
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetSecondsImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.30
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetUTCSecondsImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.31
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetMinutesImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.33
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetUTCMinutesImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.34
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetHoursImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.35
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetUTCHoursImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.36
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetDateImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.36
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetUTCDateImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.37
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetMonthImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.38
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetUTCMonthImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.39
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetFullYearImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.40
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Native.JsDateConstructor.SetUTCFullYearImpl(Jint.Native.JsDictionaryObject,Jint.Native.JsInstance[])">
            <summary>
            15.9.5.41
            </summary>
            <param name="target"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem">
            <summary>
            函数编辑绑定项。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.ParamBindingList">
            <summary>
            获取参数列表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.ExpressionCategory">
            <summary>
            获取或设置表达式类型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.FunctionCategory">
            <summary>
            获取或设置函数类别。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.MssName">
            <summary>
            获取或设置SQLServer数据库名称（DataBase模式时使用）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.OraName">
            <summary>
            获取或设置Oracle数据库名称（DataBase模式时使用）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.AssmblyName">
            <summary>
            获取或设置解析程序集名称。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.ClassFullName">
            <summary>
            获取或设置解析类的类名（包含命名空间的类型全名）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.InstanceName">
            <summary>
            获取或设置解析类的实例名称。如果此名称为空，则表示为JavaScript原生函数。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.DesignAssmblyName">
            <summary>
             获取或设置设计时调用函数自定义向导AssmblyName。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.DesignClassName">
            <summary>
            获取或设置设计时调用函数自定义向导ClassName。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.Description">
            <summary>
            获取或设置函数帮助。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionEditorBindingItem.IsParamsMethod">
            <summary>
            获取或设置是否为可变参数方法。
            </summary>
        </member>
        <member name="M:Antlr.Runtime.Tree.TreeRewriter.ReportTransformation(System.Object,System.Object)">
            Override this if you need transformation tracing to go somewhere
            other than stdout or if you're not using ITree-derived trees.
        </member>
        <member name="T:Antlr.Runtime.ANTLRInputStream">
            <summary>
            A kind of ReaderStream that pulls from an InputStream.
            Useful for reading from stdin and specifying file encodings etc...
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.ExtendConfigFile">
            <summary>
            扩展配置文件的对象化表示形式。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.ExpressionContext">
            <summary>
            表达式上下文。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExpressionContext.ResetExpressionText(System.String)">
            <summary>
            重置表达式文本(最终存储的文本)。
            </summary>
            <param name="expressionText"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExpressionContext.CreateGrammarParser">
            <summary>
            创建语法解析器。并将语法解析器中的 KeyTerm 添加到所有词法单元字典 TokenItemDic 中。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExpressionContext.ParseContext(System.Collections.Hashtable)">
            <summary>
            分类汇总各传入项
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExpressionContext.AddDefaultTokenItems">
            <summary>
            添加内置的需要将语义化名称转为英文名称的关键字、常量、运算符。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExpressionContext.AddConfigFileTokenItems(Genersoft.Platform.SemanticExpression.ExtendConfigFile)">
            <summary>
            添加配置文件中的词法单元。
            </summary>
            <param name="configFile"></param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.ExpressionContext.BuildTokenItems">
            <summary>
            构建词法单元
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedExpressionText">
            <summary>
            获取传入的表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedExpressionCategory">
            <summary>
            获取传入的表达式类型。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedExpressionFieldFormat">
             <summary>
            获取传入的数据字段格式。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedXmlSchemaEntryList">
             <summary>
            获取传入的 XmlSchema 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedExpressionConfigEntryList">
             <summary>
            获取传入的 ExpressionConfig 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedSessionVariableEntryList">
             <summary>
            获取传入的 SessionVariable 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedContextVariableEntryList">
             <summary>
            获取传入的 ContextVariable 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedSubExpressionEntryList">
             <summary>
            获取传入的 SubExpression 项。
             </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ReceivedInvalidDataEntryList">
            <summary>
            获取传入的无效数据项列表。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ParsedXsdDocumentList">
            <summary>
            获取传入的 XmlSchema 项解析后的 XmlSchema 文档。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ParsedExpressionConfigFileList">
            <summary>
            获取传入的  ExpressionConfig 文件解析后的文档。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ParsedExpressionVersion">
            <summary>
            获取传入的表达式的版本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.ParsedSyntaxText">
            <summary>
            获取传入的表达式文本用于在 SyntaxRichTextBox 中显示的文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.GrammarParser">
            <summary>
            获取语法解析器。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.IdentifierDic">
            <summary>
            获取标识符字典（包括：系统变量、上下文变量、子表达式、字段、函数）。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.TokenItemDic">
            <summary>
            获取语义化词法单元字典。在生成英文表达式时，需要将语义化词条进行转换。key:语义化名称； value:词法单元。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.ExpressionContext.LocalVariableList">
            <summary>
            获取局部变量的标识符列表（用户定义的局部变量，此列表在每次语法校验时会首先清空）。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventArgs">
            <summary>
            请求保存表达式的事件数据。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventArgs.ExpressionText">
            <summary>
            获取表达式文本。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventArgs.CnExpr">
            <summary>
            获取内存中文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventArgs.EnExpr">
            <summary>
            获取内存英文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventArgs.MssCnExpr">
            <summary>
            获取SQLServer数据库中文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventArgs.MssEnExpr">
            <summary>
            获取SQLServer数据库英文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventArgs.OraCnExpr">
            <summary>
            获取Oracle数据库中文表达式。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Builder.SemanticExprEventArgs.OraEnExpr">
            <summary>
            获取Oracle数据库英文表达式。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Common.ExpressionCategory">
            <summary>
            表达式类型（MemoryMode|DataBase|SQLServer|Oracle）。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Common.ExpressionCategory.MemoryMode">
            <summary>
            内存解析类型。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Common.ExpressionCategory.DataBase">
            <summary>
            数据库类型。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Common.ExpressionCategory.SQLServer">
            <summary>
            SQL Server 数据库类型。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Common.ExpressionCategory.Oracle">
            <summary>
            Oracle数据库类型。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.FunctionBindingItem">
            <summary>
            函数标识符绑定项。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.FunctionBindingItem.Parameters">
            <summary>
            获取或设置参数列表。
            </summary>
        </member>
        <member name="T:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator">
            <summary>
            语义化表达式解析器。注意：此类的实例只能在创建该实例的线程中使用。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.CURRENTROWINDEX">
            <summary>
            上下文变量字典中表示当前行的键值。
            </summary>
        </member>
        <member name="F:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.DATATABLECURRENTROWINDEX">
            <summary>
            每个数据表的 ExtendedProperties 集合中表示当前行的键值。
            </summary>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.#ctor(Genersoft.Platform.SemanticExpression.Evaluation.EvaluatorDataSourceMode)">
            <summary>
            创建对象的新实例。
            </summary>
            <param name="evaluatorDataSourceMode">求值时使用哪个数据源。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.AddObject(System.String,System.Object)">
            <summary>
            添加解析对象。
            </summary>
            <param name="name">对象实例名称。</param>
            <param name="obj">对象实例。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.AddDataSet(System.String,System.Data.DataSet)">
            <summary>
            添加数据集。
            </summary>
            <param name="name">数据模型英文名称。</param>
            <param name="dataSet">数据集。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.AddSessionVariable(System.String,System.Object)">
            <summary>
            添加系统变量。
            </summary>
            <param name="name">变量英文名称。</param>
            <param name="value">变量的值。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.AddContextVariable(System.String,System.Object)">
            <summary>
            添加上下文变量。
            </summary>
            <param name="name">变量英文名称。</param>
            <param name="value">变量的值。</param>
        </member>
        <member name="M:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.Evaluator(System.String)">
            <summary>
            计算表达式的值。
            </summary>
            <param name="expression">表达式文本。</param>
            <returns>表达式的值。</returns>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.EvaluatorContext">
            <summary>
            获取或设置解析上下文。
            </summary>
        </member>
        <member name="P:Genersoft.Platform.SemanticExpression.Evaluation.SemanticExprEvaluator.RecordNotFindMode">
            <summary>
            获取或设置一个值，该值指示当要获取数据的行号不存在时，该返回何值。该属性的默认值为返回空字符串。
            </summary>
        </member>
        <member name="T:Jint.Marshaller">
            <summary>
            Marshals clr objects to js objects and back. It can marshal types, delegates and other types of objects.
            </summary>
            <remarks>
            <pre>
            Marshaller holds a reference to a global object which is used to get a prototype while marshalling from
            clr to js. Futhermore a marshaller is to be accessible while running a script, therefore it strictly
            linked to the global object which defines a runtime environment for the script.
            </pre>
            </remarks>
        </member>
        <member name="M:Jint.Marshaller.#ctor(Jint.Native.IGlobal)">
            <summary>
            Constaructs a new marshaller object.
            </summary>
            <param name="global">A global object which can be used for constructing new JsObjects while marshalling.</param>
        </member>
        <member name="M:Jint.Marshaller.MarshalClrValue``1(``0)">
            <summary>
            Marshals a native value to a JsInstance
            </summary>
            <typeparam name="T">A type of a native value</typeparam>
            <param name="value">A native value</param>
            <returns>A marshalled JsInstance</returns>
        </member>
        <member name="M:Jint.Marshaller.CreateConstructor(System.Type,Jint.Native.JsObject)">
            <summary>
            Creates a constructor for a native type and sets its 'prototype' property to
            the object derived from a <paramref name="prototypePropertyPrototype"/>.
            </summary>
            <remarks>
            For example native strings should be derived from <c>'String'</c> class i.e. they should
            contain a <c>String.prototype</c> object in theirs prototype chain.
            </remarks>
            <param name="t"></param>
            <param name="prototypePropertyPrototype"></param>
            <returns></returns>
        </member>
        <member name="M:Jint.Marshaller.MarshalJsValue``1(Jint.Native.JsInstance)">
            <summary>
            Marshals a JsInstance to a native value.
            </summary>
            <typeparam name="T">A native object type</typeparam>
            <param name="value">A JsInstance to marshal</param>
            <returns>A converted native velue</returns>
        </member>
        <member name="M:Jint.Marshaller.MarshalJsValueBoxed``1(Jint.Native.JsInstance)">
            <summary>
            This is a temporary solution... Used when calling a members on value types.
            </summary>
            <remarks>
            This method used to get a reference to the boxed value type, then a reference is
            unboxed to managed pointer and then is used as the first argument in a method call.
            </remarks>
            <typeparam name="T">Type of value type, which we desire to get</typeparam>
            <param name="value">A js value which should be marshalled</param>
            <returns>A reference to a boxed value</returns>
        </member>
        <member name="M:Jint.Marshaller.GetInstanceType(Jint.Native.JsInstance)">
            <summary>
            Gets a type of a native object represented by the current JsInstance.
            If JsInstance is a pure JsObject than returns a type of js object itself.
            </summary>
            <remarks>
            If a value is a wrapper around native value (like String, Number or a marshaled native value)
            this method returns a type of a stored value.
            If a value is an js object (constructed with a pure js function) this method returns
            a type of this value (for example JsArray, JsObject)
            </remarks>
            <param name="value">JsInstance value</param>
            <returns>A Type object</returns>
        </member>
        <member name="M:Jint.Marshaller.WrapMethod(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            Converts a native method to a standard delegate.
            </summary>
            <param name="info">A method to wrap</param>
            <param name="passGlobal">If this paramerter is true and the first argument of the constructor
            is IGlobal, a wrapper delegate will pass a Global JS object in the first parameter.</param>
            <returns>A wrapper delegate</returns>
        </member>
        <member name="M:Jint.Marshaller.WrapConstructor(System.Reflection.ConstructorInfo,System.Boolean)">
            <summary>
            Converts a constructor to a standart delegate
            </summary>
            <param name="info">A constructor to wrap</param>
            <param name="passGlobal">If this paramerter is true and the first argument of the constructor
            is IGlobal, a wrapper delegate will pass a Global JS object in the first parameter.</param>
            <returns>A wrapper delegate</returns>
        </member>
        <member name="M:Jint.Marshaller.MarshalPropertyInfo(System.Reflection.PropertyInfo,Jint.Native.JsDictionaryObject)">
            <summary>
            Marshals a native property to a descriptor
            </summary>
            <param name="prop">Property to marshal</param>
            <param name="owner">Owner of the returned descriptor</param>
            <returns>A descriptor</returns>
        </member>
        <member name="M:Jint.Marshaller.MarshalFieldInfo(System.Reflection.FieldInfo,Jint.Native.JsDictionaryObject)">
            <summary>
            Marshals a native field to a JS Descriptor
            </summary>
            <param name="prop">Field info to marshal</param>
            <param name="owner">Owner for the descriptor</param>
            <returns>Descriptor</returns>
        </member>
        <member name="M:Jint.ExecutionVisitor.ResetContinueIfPresent(System.String)">
            <summary>
            Called by a loop to stop the "continue" keyword escalation
            </summary>
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._root">
            <summary>Pull nodes from which tree?</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream.tokens">
            <summary>If this tree (root) was created from a token stream, track it.</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._adaptor">
            <summary>What tree adaptor was used to build these trees</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._it">
            The tree iterator we are using 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._calls">
            <summary>Stack of indexes used for push/pop calls</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._hasNilRoot">
            <summary>Tree (nil A B C) trees like flat A B C streams</summary> 
        </member>
        <member name="F:Antlr.Runtime.Tree.CommonTreeNodeStream._level">
            <summary>Tracks tree depth.  Level=0 means we're at root node level.</summary> 
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.Push(System.Int32)">
            Make stream jump to a new location, saving old location.
            Switch back with pop().
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.Pop">
            Seek back to previous index saved during last push() call.
            Return top of stack (return index).
        </member>
        <member name="M:Antlr.Runtime.Tree.CommonTreeNodeStream.ToTokenTypeString">
            <summary>For debugging; destructive: moves tree iterator to end.</summary> 
        </member>
    </members>
</doc>
